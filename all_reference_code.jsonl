{"task_id": "stagepipe3", "code": "// Instruction types\n`define ADD_INST 2'b00\n`define SUB_INST 2'b01\nmodule verified_stagepipe3(\n    input clk,\n    input rst,\n    input [31:0] instr_mem [0:31],\n    input [31:0] reg_file [0:31],\n    output [31:0] out_reg_file  \n);\nwire [31:0] inst;\nwire [31:0] result;\n\nfetch_stage fetch (.clk(clk), .inst(inst), .rst(rst), .instr_mem_in(instr_mem));\nexecute_stage execute (\n  .clk(clk),\n  .inst(inst),\n  .reg_file(reg_file),\n  .result(result)\n);\nwriteback_stage writeback (\n  .clk(clk),\n  .result(result),\n  .reg_file(out_reg_file)\n);\nendmodule\n\n  \n// Pipeline stages \nmodule fetch_stage(\n  input clk,\n  output reg [31:0] inst,\n  input [31:0] instr_mem_in [0:31],\n  input rst\n);\n  reg [31:0] pc;\n  // Fetch logic\n  always @(posedge clk or posedge rst) begin\n    // Fetch next instruction\n    if(rst)\n    \tbegin\n    \tpc <= 0;\n    \tinst <= 0;\n    \tend\n    else \n    \tbegin\n    \tinst <= instr_mem_in[pc>>2];\n    \tpc <= pc + 4;\n    \tend\n  end\nendmodule\nmodule execute_stage(\n  input clk,\n  input [31:0] inst,\n  input [31:0] reg_file [0:31],\n  output reg [31:0] result\n);\n\n  // Decode and read operands\n  always @(posedge clk) begin\n    case(inst[31:30])\n      `ADD_INST: begin\n        result<= reg_file[inst[29:25]]+reg_file[inst[24:20]];\n      end\n      `SUB_INST: begin\n        result <= reg_file[inst[29:25]]-reg_file[inst[24:20]];\n      end\n      default: begin\n        result <= 0;\n      end\n    endcase\n  end\nendmodule \nmodule writeback_stage(\n  input clk,\n  input [31:0] result,\n  // Writeback\n  output reg [31:0] reg_file \n);\n  always @(posedge clk) begin\n    reg_file <= result;\n  end\nendmodule\n"}
{"task_id": "stagepipe5", "code": "// Instruction types\n`define ADD_INST 2'b00\n`define SUB_INST 2'b01\n\n// Pipeline stages\nmodule verified_stagepipe5(\n  input clk,\n  input rst,\n  input [31:0] instr_mem [0:31],\n  input [31:0] reg_file [0:31],\n  output [31:0] res_reg_file [0:31]\n);\n\n// Pipeline signals\nwire [31:0] inst, pc, op1, op2, result, mem_data;\nwire [4:0] rs1, rs2, rd, rd1, rd2;\nwire [1:0] op;\n\nfetch_stage fetch (.clk(clk), .inst(inst), .rst(rst), .instr_mem_in(instr_mem));\ndecode_stage decode (\n  .clk(clk),\n  .inst(inst),\n  .rs1(rs1),\n  .rs2(rs2),\n  .op(op),\n  .rd(rd)\n);\nexecute_stage execute (\n  .clk(clk),\n  .rs1(rs1),\n  .rs2(rs2),\n  .reg_file(reg_file),\n  .op(op),\n  .result(result),\n  .rdin1(rd),\n  .rdout1(rd1)\n);\nmemory_stage memory(.clk(clk), .alu_result(result), .mem_data(mem_data), .rdin2(rd1), .rdout2(rd2));\nwriteback_stage writeback (\n  .clk(clk),\n  .mem_data(mem_data),\n  .rd(rd2),\n  .reg_file(res_reg_file)\n);\nendmodule\n\nmodule fetch_stage(\n  input clk,\n  output reg [31:0] inst,\n  input [31:0] instr_mem_in [0:31],\n  input rst\n);\n  reg [31:0] pc;\n  // Fetch logic\n  always @(posedge clk or posedge rst) begin\n    // Fetch next instruction\n    if(rst)\n    \tbegin\n    \tpc <= 0;\n    \tinst <= 0;\n    \tend\n    else \n    \tbegin\n    \tinst <= instr_mem_in[pc>>2];\n    \tpc <= pc + 4;\n    \tend\n  end\nendmodule\nmodule decode_stage(\n  input clk,\n  input [31:0] inst,\n  output reg [4:0] rs1,\n  output reg [4:0] rs2,\n  output reg [1:0] op,\n  output reg [4:0] rd\n\n);\n  always @(posedge clk) begin\n    rs1 <= inst[29:25];\n    rs2 <= inst[24:20];\n    op <= inst[31:30];\n    rd <= inst[4:0];\n  end\nendmodule\nmodule execute_stage(\n  input clk,\n  input [4:0] rs1,\n  input [4:0] rs2,\n  input [31:0] reg_file [0:31],\n  input [1:0] op,\n  output reg [31:0] result,\n  input [4:0] rdin1,//\n  output reg [4:0] rdout1//\n);\n\n  always @(posedge clk) begin\n    case(op)\n      `ADD_INST: begin\n        result<= reg_file[rs1] + reg_file[rs2];\n      end\n      `SUB_INST: begin\n        result<= reg_file[rs1] - reg_file[rs2];\n      end\n      default: begin\n        result <= 0;\n      end\n    endcase\n    rdout1<=rdin1;//\n  end\nendmodule\n\nmodule memory_stage(\n  input clk,\n  input [31:0] alu_result,\n  output reg [31:0] mem_data,\n  input [4:0] rdin2,//\n  output reg [4:0] rdout2//\n);\n  always @(posedge clk) begin\n    mem_data <= alu_result; // Read memory\n    rdout2<=rdin2;//\n  end\nendmodule\n\nmodule writeback_stage(\n  input clk,\n  input [31:0] mem_data,\n  input [4:0] rd,\n  output reg [31:0] reg_file[0:31]\n);\n  always @(posedge clk) begin\n     reg_file[rd] <= mem_data; // Writeback\n  end\nendmodule\n"}
{"task_id": "systolic1x2", "code": "module verified_systolic1x2 (\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1\n);\n  reg [15:0] b1;\n  PE pe0 (\n    .clk(clk),\n    .rst(rst),\n    .a(a0),\n    .b(b0),\n    .c(c0)\n  );\n  PE pe1 (\n    .clk(clk),\n    .rst(rst),\n    .a(a1),\n    .b(b1),\n    .c(c1)\n  );\n  always@(posedge clk or posedge rst) begin\n    if(rst) begin\n      b1 <= 0;\n    end\n    else begin\n      b1 <= b0; // pass b0 to next PE\n    end\n  end\n  \nendmodule\n\nmodule PE (\n  input clk,\n  input rst,\n  input [15:0] a,\n  input [15:0] b,\n  output[31:0] c\n);\n  reg [31:0] r;\n  always @(posedge clk or posedge rst) begin\n    if (rst)\n      r <= 0;\n    else\n      r <= r + (a * b);\n  end\n  assign c = r;\nendmodule"}
{"task_id": "systolic1x4", "code": "module verified_systolic1x4(\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] a2,\n  input [15:0] a3,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1,\n  output [31:0] c2,\n  output [31:0] c3 \n);\nreg [15:0] b1, b2, b3;\n// 4 PEs\nPE pe0(.clk(clk), .rst(rst), .a(a0), .b(b0), .c(c0));\nPE pe1(.clk(clk), .rst(rst), .a(a1), .b(b1), .c(c1));\nPE pe2(.clk(clk), .rst(rst), .a(a2), .b(b2), .c(c2));\nPE pe3(.clk(clk), .rst(rst), .a(a3), .b(b3), .c(c3));\n// Cascade b connections \nalways@(posedge clk or posedge rst) begin\n  if (rst) begin\n    b1 <= 0;\n    b2 <= 0;\n    b3 <= 0;\n  end\n  else begin\n    b1 <= b0; // pass b0 to next PE\n    b2 <= b1;\n    b3 <= b2;\n  end\nend\nendmodule\n\nmodule PE (\n  input clk,\n  input rst,\n  input [15:0] a,\n  input [15:0] b,\n  output[31:0] c\n);\n  reg [31:0] r;\n  always @(posedge clk or posedge rst) begin\n    if (rst)\n      r <= 0;\n    else\n      r <= r + (a * b);\n  end\n  assign c = r;\nendmodule"}
{"task_id": "systolic2x2", "code": "\nmodule verified_systolic2x2(\n  input clk,\n  input rst,\n  input [15:0] weight [0:1] [0:1], // weight station\n  input [15:0] inputt [0:1] [0:1],        // input buffer\n  output [31:0] outputt [0:1] [0:1]      // output buffer \n);\n// PE instances\nPE pe00(.clk(clk), .rst(rst), .a(inputt[0][0]), .b(weight[0][0]), .c(outputt[0][0]));\nPE pe01(.clk(clk), .rst(rst), .a(inputt[0][1]), .b(weight[0][1]), .c(outputt[0][1]));\nPE pe10(.clk(clk), .rst(rst), .a(inputt[1][0]), .b(weight[1][0]), .c(outputt[1][0]));\nPE pe11(.clk(clk), .rst(rst), .a(inputt[1][1]), .b(weight[1][1]), .c(outputt[1][1]));\nendmodule\n\nmodule PE (\n  input clk,\n  input rst,\n  input [15:0] a,\n  input [15:0] b,\n  output[31:0] c\n);\n  reg [31:0] r;\n  always @(posedge clk or posedge rst) begin\n    if (rst)\n      r <= 0;\n    else\n      r <= r + (a * b);\n  end\n  assign c = r;\nendmodule"}
{"task_id": "systolic4x4", "code": "module verified_systolic4x4(\n  input clk,\n  input rst,\n  input [15:0] weight [0:3] [0:3],\n  input [15:0] inputt [0:15],\n  output [31:0] outputt [0:15]  \n);\n// Instantiate 16 PEs \nPE pe00(.clk(clk), .rst(rst), .a(inputt[0]), .b(weight[0][0]), .c(outputt[0]));\nPE pe01(.clk(clk), .rst(rst), .a(inputt[1]), .b(weight[0][1]), .c(outputt[1]));\nPE pe02(.clk(clk), .rst(rst), .a(inputt[2]), .b(weight[0][2]), .c(outputt[2]));\nPE pe03(.clk(clk), .rst(rst), .a(inputt[3]), .b(weight[0][3]), .c(outputt[3]));\nPE pe04(.clk(clk), .rst(rst), .a(inputt[4]), .b(weight[1][0]), .c(outputt[4]));\nPE pe05(.clk(clk), .rst(rst), .a(inputt[5]), .b(weight[1][1]), .c(outputt[5]));\nPE pe06(.clk(clk), .rst(rst), .a(inputt[6]), .b(weight[1][2]), .c(outputt[6]));\nPE pe07(.clk(clk), .rst(rst), .a(inputt[7]), .b(weight[1][3]), .c(outputt[7]));\nPE pe08(.clk(clk), .rst(rst), .a(inputt[8]), .b(weight[2][0]), .c(outputt[8]));\nPE pe09(.clk(clk), .rst(rst), .a(inputt[9]), .b(weight[2][1]), .c(outputt[9]));\nPE pe10(.clk(clk), .rst(rst), .a(inputt[10]), .b(weight[2][2]), .c(outputt[10]));\nPE pe11(.clk(clk), .rst(rst), .a(inputt[11]), .b(weight[2][3]), .c(outputt[11]));\nPE pe12(.clk(clk), .rst(rst), .a(inputt[12]), .b(weight[3][0]), .c(outputt[12]));\nPE pe13(.clk(clk), .rst(rst), .a(inputt[13]), .b(weight[3][1]), .c(outputt[13]));\nPE pe14(.clk(clk), .rst(rst), .a(inputt[14]), .b(weight[3][2]), .c(outputt[14]));\nPE pe15(.clk(clk), .rst(rst), .a(inputt[15]), .b(weight[3][3]), .c(outputt[15]));\n\nendmodule\n\nmodule PE (\n  input clk,\n  input rst,\n  input [15:0] a,\n  input [15:0] b,\n  output[31:0] c\n);\n  reg [31:0] r;\n  always @(posedge clk or posedge rst) begin\n    if (rst)\n      r <= 0;\n    else\n      r <= r + (a * b);\n  end\n  assign c = r;\nendmodule"}
{"task_id": "accu", "code": "`timescale 1ns/1ps\n\nmodule verified_accu (\n    input               clk,\n    input               rst_n,\n    input       [7:0]   data_in,\n    input               valid_in,\n\n    output              valid_out,\n    output      [9:0]   data_out\n);\n\n    wire [2:0] count;\n    wire add_cnt;\n    wire end_cnt;\n    wire ready_add;\n    wire [9:0] data_out_reg;\n\n    // Instantiate the counter module\n    counter u_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .add_cnt(add_cnt),\n        .end_cnt(end_cnt),\n        .count(count)\n    );\n\n    // Instantiate the data accumulation module\n    data_accumulator u_data_accumulator (\n        .clk(clk),\n        .rst_n(rst_n),\n        .data_in(data_in),\n        .add_cnt(add_cnt),\n\t\t.count(count),\n        .data_out(data_out_reg)\n    );\n\n    // Instantiate the valid output module\n    valid_output u_valid_output (\n        .clk(clk),\n        .rst_n(rst_n),\n        .end_cnt(end_cnt),\n        .valid_out(valid_out)\n    );\n\n    assign add_cnt = ready_add;\n    assign end_cnt = ready_add && (count == 'd4);\n    assign ready_add = valid_in;\n    assign data_out = data_out_reg;\n\nendmodule\n\nmodule counter (\n    input               clk,\n    input               rst_n,\n    input               add_cnt,\n    input               end_cnt,\n    output reg [2:0]   count\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count <= 0;\n        end\n        else if (end_cnt||count=='d4) begin\n            count <= 0;\n        end\n        else if (add_cnt) begin\n            count <= count + 1;\n        end\n    end\n\nendmodule\n\nmodule data_accumulator (\n    input               clk,\n    input               rst_n,\n    input       [7:0]   data_in,\n    input               add_cnt,\n\tinput \t\t[2:0]  count,\n    output reg [9:0]   data_out\n);\n\n    reg [9:0] data_out_reg;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            data_out_reg <= 0;\n        end\n        else if (add_cnt && (count == 'd0)) begin\n            data_out_reg <= data_in;\n        end\n        else if (add_cnt) begin\n            data_out_reg <= data_out_reg + data_in;\n        end\n    end\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            data_out <= 0;\n        end\n        else begin\n            data_out <= data_out_reg;\n        end\n    end\n\nendmodule\n\n\nmodule valid_output (\n    input               clk,\n    input               rst_n,\n    input               end_cnt,\n    output reg         valid_out\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            valid_out <= 0;\n        end\n        else \n            valid_out <= end_cnt;\n    end\n\nendmodule\n"}
{"task_id": "adder_16bit", "code": "module verified_adder_16bit (\n    input wire [15:0] a,\n    input wire [15:0] b,\n    input wire Cin,\n    output wire [15:0] y,\n    output wire Co\n);\n \n    wire Co_temp;\n \n    add8 add8_inst1 (\n        .a(a[15:8]),\n        .b(b[15:8]),\n        .Cin(Co_temp), \n        .y(y[15:8]),\n        .Co(Co)\n    );\n \n    add8 add8_inst2 (\n        .a(a[7:0]),\n        .b(b[7:0]),\n        .Cin(Cin),\n        .y(y[7:0]),\n        .Co(Co_temp)\n    ); \n \nendmodule\n\nmodule add8 (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    input wire Cin,\n    output wire [7:0] y,\n    output wire Co\n);\n \n    wire Co_temp;\n \n    add4 add4_inst1 (\n        .a(a[7:4]),\n        .b(b[7:4]),\n        .Cin(Co_temp),\n        .y(y[7:4]),\n        .Co(Co)\n    );\n \n    add4 add4_inst2 (\n        .a(a[3:0]),\n        .b(b[3:0]),\n        .Cin(Cin),\n        .y(y[3:0]),\n        .Co(Co_temp)\n    );\n \nendmodule\n\nmodule add4 (\n    input wire [3:0] a,\n    input wire [3:0] b,\n    input wire Cin,\n    output wire [3:0] y,\n    output wire Co\n);\n \n    wire Co_temp;\n \n    add2 add2_inst1 (\n        .a(a[3:2]),\n        .b(b[3:2]),\n        .Cin(Co_temp),\n        .y(y[3:2]),\n        .Co(Co)\n    );\n \n    add2 add2_inst2 (\n        .a(a[1:0]),\n        .b(b[1:0]),\n        .Cin(Cin),\n        .y(y[1:0]),\n        .Co(Co_temp)\n    ); \n \nendmodule\n\nmodule add2 (\n    input wire [1:0] a,\n    input wire [1:0] b,\n    input wire Cin,\n    output wire [1:0] y,\n    output wire Co\n);\n \n    wire Co_temp;\n\n    add1 add1_inst1 (\n        .a(a[1]),\n        .b(b[1]),\n        .Cin(Co_temp),\n        .y(y[1]),\n        .Co(Co)\n    );\n \n    add1 add1_inst2 (\n        .a(a[0]),\n        .b(b[0]),\n        .Cin(Cin),\n        .y(y[0]),\n        .Co(Co_temp)\n    );\n         \nendmodule\n\nmodule add1 (\n    input wire a,\n    input wire b,\n    input wire Cin,\n    output wire y,\n    output wire Co\n);\n    assign y = ((~a) & (~b) & Cin | (~a) & b & (~Cin) | a & (~b) & (~Cin) | (a & b & Cin));\n    assign Co = ((~a & b & Cin) | (a & ~b & Cin) | (a & b & ~Cin) | (a & b & Cin));\n\nendmodule"}
{"task_id": "adder_16bit_csa", "code": "`timescale 1ns / 1ns\n\nmodule verified_adder_16bit_csa(a, b, cin, sum, cout);\ninput [15:0] a,b;\ninput cin;\noutput [15:0] sum;\noutput cout;\n\nwire [2:0] c;\n\nripple_carry_4_bit rca1(\n.a(a[3:0]),\n.b(b[3:0]),\n.cin(cin),\n.sum(sum[3:0]),\n.cout(c[0]));\n\n// first 4-bit by ripple_carry_adder\ncarry_select_adder_4bit_slice csa_slice1(\n.a(a[7:4]),\n.b(b[7:4]),\n.cin(c[0]),\n.sum(sum[7:4]),\n.cout(c[1]));\n\ncarry_select_adder_4bit_slice csa_slice2(\n.a(a[11:8]),\n.b(b[11:8]),\n.cin(c[1]),\n.sum(sum[11:8]), \n.cout(c[2]));\n\ncarry_select_adder_4bit_slice csa_slice3(\n.a(a[15:12]),\n.b(b[15:12]),\n.cin(c[2]),\n.sum(sum[15:12]),\n.cout(cout));\nendmodule\n\n//////////////////////////////////////\n//4-bit Carry Select Adder Slice\n//////////////////////////////////////\n\nmodule carry_select_adder_4bit_slice(a, b, cin, sum, cout);\ninput [3:0] a,b;\ninput cin;\noutput [3:0] sum;\noutput cout;\n\nwire [3:0] s0,s1;\nwire c0,c1;\n\nripple_carry_4_bit rca1(\n.a(a[3:0]),\n.b(b[3:0]),\n.cin(1'b0),\n.sum(s0[3:0]),\n.cout(c0));\n\nripple_carry_4_bit rca2(\n.a(a[3:0]),\n.b(b[3:0]),\n.cin(1'b1),\n.sum(s1[3:0]),\n.cout(c1));\n\nmux2X1 #(4) ms0(\n.in0(s0[3:0]),\n.in1(s1[3:0]),\n.sel(cin),\n.out(sum[3:0]));\n\nmux2X1 #(1) mc0(\n.in0(c0),\n.in1(c1),\n.sel(cin),\n.out(cout));\nendmodule\n\n/////////////////////\n//2X1 Mux\n/////////////////////\n\nmodule mux2X1( in0,in1,sel,out);\nparameter width=16; \ninput [width-1:0] in0,in1;\ninput sel;\noutput [width-1:0] out;\nassign out=(sel)?in1:in0;\nendmodule\n\n\n/////////////////////////////////\n//4-bit Ripple Carry Adder\n/////////////////////////////////\nmodule ripple_carry_4_bit(a, b, cin, sum, cout);\ninput [3:0] a,b;\ninput cin;\noutput [3:0] sum;\noutput cout;\n\nwire c1,c2,c3;\n\nfull_adder fa0(\n.a(a[0]),\n.b(b[0]),\n.cin(cin),\n.sum(sum[0]),\n.cout(c1));\n\nfull_adder fa1(\n.a(a[1]),\n.b(b[1]),\n.cin(c1),\n.sum(sum[1]),\n.cout(c2));\n\nfull_adder fa2(\n.a(a[2]),\n.b(b[2]),\n.cin(c2),\n.sum(sum[2]),\n.cout(c3));\n\nfull_adder fa3(\n.a(a[3]),\n.b(b[3]),\n.cin(c3),\n.sum(sum[3]),\n.cout(cout));\nendmodule\n\n/////////////////////\n//1bit Full Adder\n/////////////////////\n\nmodule full_adder(a,b,cin,sum, cout);\ninput a,b,cin;\noutput sum, cout;\n\nwire x,y,z;\n\nhalf_adder h1(.a(a), .b(b), .sum(x), .cout(y));\nhalf_adder h2(.a(x), .b(cin), .sum(sum), .cout(z));\nor or_1(cout,z,y);\nendmodule\n\n//////////////////////\n// 1 bit Half Adder\n//////////////////////\n\nmodule half_adder( a,b, sum, cout );\ninput a,b;\noutput sum, cout;\nxor xor_1 (sum,a,b);\nand and_1 (cout,a,b);\nendmodule"}
{"task_id": "adder_32bit", "code": "module verified_adder_32bit(A,B,S,C32);\n     input [32:1] A;\n     input [32:1] B;\n     output [32:1] S;\n     output C32;\n\n     wire px1,gx1,px2,gx2;\n     wire c16;\n\n  CLA_16 CLA1(\n      .A(A[16:1]),\n        .B(B[16:1]),\n        .c0(0),\n        .S(S[16:1]),\n        .px(px1),\n        .gx(gx1)\n    );\n\n  CLA_16 CLA2(\n        .A(A[32:17]),\n          .B(B[32:17]),\n          .c0(c16),\n          .S(S[32:17]),\n          .px(px2),\n          .gx(gx2)\n    );\n\n  assign c16 = gx1 ^ (px1 && 0), //c0 = 0\n         C32 = gx2 ^ (px2 && c16);\nendmodule\n\nmodule CLA_16(A,B,c0,S,px,gx);\n    input [16:1] A;\n    input [16:1] B;\n    input c0;\n    output gx,px;\n    output [16:1] S;\n\n    wire c4,c8,c12;\n    wire Pm1,Gm1,Pm2,Gm2,Pm3,Gm3,Pm4,Gm4;\n\n    adder_4 adder1(\n         .x(A[4:1]),\n          .y(B[4:1]),\n          .c0(c0),\n          .c4(),\n          .F(S[4:1]),\n          .Gm(Gm1),\n          .Pm(Pm1)\n    );\n\n    adder_4 adder2(\n         .x(A[8:5]),\n          .y(B[8:5]),\n          .c0(c4),\n          .c4(),\n          .F(S[8:5]),\n          .Gm(Gm2),\n          .Pm(Pm2)\n    );\n\n    adder_4 adder3(\n         .x(A[12:9]),\n          .y(B[12:9]),\n          .c0(c8),\n          .c4(),\n          .F(S[12:9]),\n          .Gm(Gm3),\n          .Pm(Pm3)\n    );\n\n    adder_4 adder4(\n         .x(A[16:13]),\n          .y(B[16:13]),\n          .c0(c12),\n          .c4(),\n          .F(S[16:13]),\n          .Gm(Gm4),\n          .Pm(Pm4)\n    );\n\n    assign   c4 = Gm1 ^ (Pm1 & c0),\n             c8 = Gm2 ^ (Pm2 & Gm1) ^ (Pm2 & Pm1 & c0),\n             c12 = Gm3 ^ (Pm3 & Gm2) ^ (Pm3 & Pm2 & Gm1) ^ (Pm3 & Pm2 & Pm1 & c0);\n\n    assign  px = Pm1 & Pm2 & Pm3 & Pm4,\n            gx = Gm4 ^ (Pm4 & Gm3) ^ (Pm4 & Pm3 & Gm2) ^ (Pm4 & Pm3 & Pm2 & Gm1);\nendmodule\n\nmodule adder_4(x,y,c0,c4,F,Gm,Pm);\n      input [4:1] x;\n      input [4:1] y;\n      input c0;\n      output c4,Gm,Pm;\n      output [4:1] F;\n\n      wire p1,p2,p3,p4,g1,g2,g3,g4;\n      wire c1,c2,c3;\n      adder adder1(\n                 .X(x[1]),\n                     .Y(y[1]),\n                     .Cin(c0),\n                     .F(F[1]),\n                     .Cout()\n                );\n\n      adder adder2(\n                 .X(x[2]),\n                     .Y(y[2]),\n                     .Cin(c1),\n                     .F(F[2]),\n                     .Cout()\n                );  \n\n      adder adder3(\n                 .X(x[3]),\n                     .Y(y[3]),\n                     .Cin(c2),\n                     .F(F[3]),\n                     .Cout()\n                );\n\n      adder adder4(\n                 .X(x[4]),\n                     .Y(y[4]),\n                     .Cin(c3),\n                     .F(F[4]),\n                     .Cout()\n                );      \n\n        CLA CLA(\n            .c0(c0),\n            .c1(c1),\n            .c2(c2),\n            .c3(c3),\n            .c4(c4),\n            .p1(p1),\n            .p2(p2),\n            .p3(p3),\n            .p4(p4),\n            .g1(g1),\n            .g2(g2),\n            .g3(g3),\n            .g4(g4)\n        );\n\n\n\n  assign   p1 = x[1] ^ y[1],      \n           p2 = x[2] ^ y[2],\n           p3 = x[3] ^ y[3],\n           p4 = x[4] ^ y[4];\n\n  assign   g1 = x[1] & y[1],\n           g2 = x[2] & y[2],\n           g3 = x[3] & y[3],\n           g4 = x[4] & y[4];\n\n  assign Pm = p1 & p2 & p3 & p4,\n         Gm = g4 ^ (p4 & g3) ^ (p4 & p3 & g2) ^ (p4 & p3 & p2 & g1);\nendmodule\n\nmodule CLA(c0,c1,c2,c3,c4,p1,p2,p3,p4,g1,g2,g3,g4);\n\n     input c0,g1,g2,g3,g4,p1,p2,p3,p4;\n     output c1,c2,c3,c4;\n\n     assign c1 = g1 ^ (p1 & c0),\n            c2 = g2 ^ (p2 & g1) ^ (p2 & p1 & c0),\n            c3 = g3 ^ (p3 & g2) ^ (p3 & p2 & g1) ^ (p3 & p2 & p1 & c0),\n            c4 = g4^(p4&g3)^(p4&p3&g2)^(p4&p3&p2&g1)^(p4&p3&p2&p1&c0);\nendmodule\n\nmodule adder(X,Y,Cin,F,Cout);\n\n  input X,Y,Cin;\n  output F,Cout;\n\n  assign F = X ^ Y ^ Cin;\n  assign Cout = (X ^ Y) & Cin | X & Y;\nendmodule"}
{"task_id": "adder_8bit", "code": "module verified_adder_8bit(\n    input [7:0] a, b, \n    input cin, \n    output [7:0] sum, \n    output cout);\n    \n    wire [8:0] c;\n\n    full_adder FA0 (.a(a[0]), .b(b[0]), .cin(cin), .sum(sum[0]), .cout(c[0]));\n    full_adder FA1 (.a(a[1]), .b(b[1]), .cin(c[0]), .sum(sum[1]), .cout(c[1]));\n    full_adder FA2 (.a(a[2]), .b(b[2]), .cin(c[1]), .sum(sum[2]), .cout(c[2]));\n    full_adder FA3 (.a(a[3]), .b(b[3]), .cin(c[2]), .sum(sum[3]), .cout(c[3]));\n    full_adder FA4 (.a(a[4]), .b(b[4]), .cin(c[3]), .sum(sum[4]), .cout(c[4]));\n    full_adder FA5 (.a(a[5]), .b(b[5]), .cin(c[4]), .sum(sum[5]), .cout(c[5]));\n    full_adder FA6 (.a(a[6]), .b(b[6]), .cin(c[5]), .sum(sum[6]), .cout(c[6]));\n    full_adder FA7 (.a(a[7]), .b(b[7]), .cin(c[6]), .sum(sum[7]), .cout(c[7]));\n\n    assign cout = c[7]; \nendmodule\n\nmodule full_adder (input a, b, cin, output sum, cout);\n    assign {cout, sum} = a + b + cin;\nendmodule"}
{"task_id": "comparator_32bit", "code": "module verified_comparator_32bit(\n    input [31:0] A,   // First 32-bit input operand\n    input [31:0] B,   // Second 32-bit input operand\n    output A_greater, \n    output A_equal,   \n    output A_less     \n);\n\n    wire [31:0] diff;  \n    wire cout;       \n\n    // Instantiate the 32-bit subtractor\n    subtractor_32bit sub_inst (\n        .A(A),\n        .B(B),\n        .diff(diff),\n        .cout(cout)\n    );\n\n    // Determine the comparison outputs\n    assign A_greater = (~cout && diff != 32'b0);\n    assign A_equal = (A == B);\n    assign A_less = cout;\n\nendmodule\n\nmodule subtractor_32bit(\n    input [31:0] A,   // First operand\n    input [31:0] B,   // Second operand\n    output [31:0] diff, // Difference output\n    output cout       // Carry output (borrow for subtraction)\n);\n\n    // Perform the subtraction\n    assign {cout, diff} = A - B;\n\nendmodule"}
{"task_id": "div_16bit", "code": "module verified_div_16bit (\n    input wire [15:0] A,       // 16-bit dividend\n    input wire [7:0] B,       // 8-bit divisor\n    output wire [15:0] result, // 16-bit quotient\n    output wire [15:0] odd     // 16-bit remainder\n);\n\n    wire [15:0] quotient;\n    wire [15:0] remainder;\n\n    // Instantiate the control module\n    control_unit ctrl (\n        .A(A),\n        .B(B),\n        .quotient(quotient),\n        .remainder(remainder)\n    );\n\n    // Assign outputs\n    assign result = quotient;\n    assign odd = remainder;\n\nendmodule\n\nmodule control_unit (\n    input wire [15:0] A,\n    input wire [7:0] B,\n    output reg [15:0] quotient,\n    output reg [15:0] remainder\n);\n    reg [31:0] tmp_a;\n    reg [31:0] tmp_b;\n    integer i;\n\n    always @(*) begin\n        // Initialize temporary variables\n        tmp_a = {16'b0, A};        // Concatenate A to a 32-bit value\n        tmp_b = {B, 16'b0};        // Concatenate B to a 32-bit value\n        quotient = 0;              // Reset quotient\n        remainder = 0;             // Reset remainder\n\n        // Division algorithm\n        for (i = 0; i < 16; i = i + 1) begin\n            tmp_a = tmp_a << 1;    // Shift left to process the next bit\n            if (tmp_a >= tmp_b) begin\n                tmp_a = tmp_a - tmp_b; // Subtract divisor from dividend\n                quotient[i] = 1;        // Set quotient bit to 1\n            end else begin\n                quotient[i] = 0;        // Set quotient bit to 0\n            end\n        end\n\n        remainder = tmp_a[31:16]; // Assign remainder from the higher bits of tmp_a\n    end\nendmodule"}
{"task_id": "div_32bit", "code": "module verified_div_32bit(\n    input wire [31:0] A,   // 32-bit dividend\n    input wire [15:0] B,   // 16-bit divisor\n    output wire [31:0] result, // 32-bit quotient\n    output wire [31:0] odd      // 32-bit remainder\n);\n\n// Internal signals\nwire [63:0] tmp_a; // For holding the shifted dividend\nwire [63:0] tmp_b; // For holding the shifted divisor\nreg [31:0] quotient; // To hold the final quotient\nreg [31:0] remainder; // To hold the final remainder\n\n// Instantiate the preparatory module\nprep_dividend prep (\n    .A(A),\n    .B(B),\n    .tmp_a(tmp_a),\n    .tmp_b(tmp_b)\n);\n\n// Division operation module\ndiv_operation div_op (\n    .tmp_a(tmp_a),\n    .tmp_b(tmp_b),\n    .quotient(quotient),\n    .remainder(remainder)\n);\n\n// Assign outputs\nassign result = quotient;\nassign odd = remainder;\n\nendmodule\n\n// Module to prepare the dividend and divisor\nmodule prep_dividend(\n    input wire [31:0] A,\n    input wire [15:0] B,\n    output reg [63:0] tmp_a,\n    output reg [63:0] tmp_b\n);\n\nalways @(*) begin\n    tmp_a = {32'b0, A}; // Concatenate 32 zeros with A\n    tmp_b = {B, 32'b0}; // Concatenate B with 32 zeros\nend\n\nendmodule\n\n// Division operation module\nmodule div_operation(\n    input wire [63:0] tmp_a,\n    input wire [63:0] tmp_b,\n    output reg [31:0] quotient,\n    output reg [31:0] remainder\n);\n\ninteger i;\n\nalways @(*) begin\n    quotient = 0;\n    remainder = tmp_a; // Start with the full dividend\n\n    for (i = 0; i < 32; i = i + 1) begin\n        remainder = remainder << 1; // Shift left\n        if (remainder >= tmp_b) begin\n            remainder = remainder - tmp_b; // Subtract divisor\n            quotient = quotient | (1 << (31 - i)); // Set the quotient bit\n        end\n    end\nend\n\nendmodule"}
{"task_id": "radix2_div", "code": "`timescale 1ns/1ps\n\nmodule verified_radix2_div(\n    input wire clk,\n    input wire rst,\n    input wire [7:0] dividend,    \n    input wire [7:0] divisor,    \n    input wire sign,       \n    input wire opn_valid,   \n    output reg res_valid,   \n    input wire res_ready,   \n    output wire [15:0] result\n);\n\n    wire [7:0] dividend_abs;\n    wire [8:0] neg_divisor;\n    wire [15:0] sr;\n    wire [8:0] mux_result;\n    wire co;\n    wire [3:0] cnt;\n    wire start_cnt;\n\n    // Instantiate modules\n    abs_value abs_dividend (\n        .sign(sign),\n        .value(dividend),\n        .abs_value(dividend_abs)\n    );\n\n    neg_value neg_divisor_mod (\n        .sign(sign),\n        .value(divisor),\n        .neg_value(neg_divisor)\n    );\n\n    divider_control ctrl (\n        .clk(clk),\n        .rst(rst),\n        .opn_valid(opn_valid),\n        .start_cnt(start_cnt),\n        .cnt(cnt),\n        .sr(sr),\n        .dividend_abs(dividend_abs),\n        .neg_divisor(neg_divisor),\n        .result(result),\n        .mux_result(mux_result),\n        .co(co)\n    );\n\n    // Result management\n    result_management res_mgmt (\n        .clk(clk),\n        .rst(rst),\n        .cnt(cnt),\n        .res_valid(res_valid),\n        .res_ready(res_ready)\n    );\n\nendmodule\n\n// Module to compute absolute value of dividend\nmodule abs_value(\n    input wire sign,\n    input wire [7:0] value,\n    output wire [7:0] abs_value\n);\n    assign abs_value = (sign & value[7]) ? ~value + 1'b1 : value;\nendmodule\n\n// Module to compute negative value of divisor\nmodule neg_value(\n    input wire sign,\n    input wire [7:0] value,\n    output wire [8:0] neg_value\n);\n    assign neg_value = (sign & value[7]) ? {1'b1, value} : ~{1'b0, value} + 1'b1;\nendmodule\n\n// Module for the control logic of the division process\nmodule divider_control(\n    input wire clk,\n    input wire rst,\n    input wire opn_valid,\n    output reg start_cnt,\n    output reg [3:0] cnt,\n    output reg [15:0] sr,\n    input wire [7:0] dividend_abs,\n    input wire [8:0] neg_divisor,\n    output wire [15:0] result,\n    output wire [8:0] mux_result,\n    output wire co\n);\n    \n    always @(posedge clk) begin\n        if (rst) begin\n            sr <= 0;\n            cnt <= 0;\n            start_cnt <= 1'b0;\n        end else if (~start_cnt & opn_valid) begin\n            cnt <= 1;\n            start_cnt <= 1'b1;\n            sr <= {7'b0, dividend_abs, 1'b0}; \n        end else if (start_cnt) begin\n            if (cnt[3]) begin\n                cnt <= 0;\n                start_cnt <= 1'b0;\n                sr[15:8] <= mux_result[7:0]; // Update quotient\n                sr[0] <= co; // Update remainder\n            end else begin\n                cnt <= cnt + 1;\n                sr <= {mux_result[6:0], sr[7:1], co, 1'b0}; // Shift and update\n            end\n        end\n    end\n\n    assign {co, mux_result} = {1'b0, sr[15:8]} + neg_divisor; // Addition to check carry\n\n    assign result = {sr[15:8], sr[7:0]}; // Concatenate remainder and quotient\n\nendmodule\n\n// Module to manage result validity\nmodule result_management(\n    input wire clk,\n    input wire rst,\n    input wire [3:0] cnt,\n    output reg res_valid,\n    input wire res_ready\n);\n    always @(posedge clk) begin\n        res_valid <= rst ? 1'b0 :\n                     cnt[3] ? 1'b1 :\n                     res_ready ? 1'b0 : res_valid;\n    end\nendmodule"}
{"task_id": "multi_16bit", "code": "module verified_multi_16bit (\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    input [15:0] ain,   // Input a (multiplicand) with a data width of 16 bits.\n    input [15:0] bin,   // Input b (multiplier) with a data width of 16 bits.\n    output [31:0] yout, // Product output with a data width of 32 bits.\n    output done         // Chip output flag signal.\n);\n\n    // Internal wires and registers\n    wire [15:0] areg;\n    wire [15:0] breg;\n    wire [31:0] yout_r;\n    wire done_r;\n    wire [4:0] i;\n\n    // Instantiate the control unit\n    control_unit ctrl (\n        .clk(clk),\n        .rst_n(rst_n),\n        .start(start),\n        .i(i),\n        .done(done_r)\n    );\n\n    // Instantiate the register unit\n    register_unit reg_unit (\n        .clk(clk),\n        .rst_n(rst_n),\n        .start(start),\n        .ain(ain),\n        .bin(bin),\n        .i(i),\n        .areg(areg),\n        .breg(breg),\n        .yout_r(yout_r)\n    );\n\n    // Instantiate the multiplier unit\n    multiplier_unit mul_unit (\n        .clk(clk),\n        .rst_n(rst_n),\n        .start(start),\n        .i(i),\n        .areg(areg),\n        .breg(breg),\n        .yout_r(yout_r)\n    );\n\n    // Output assignments\n    assign done = done_r;\n    assign yout = yout_r;\n\nendmodule\n\n// Control Unit\nmodule control_unit (\n    input clk,\n    input rst_n,\n    input start,\n    output reg [4:0] i,\n    output reg done\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            i <= 5'd0;\n            done <= 1'b0;\n        end\n        else if (start && i < 5'd17) begin\n            i <= i + 1'b1;\n        end\n        else if (!start) begin\n            i <= 5'd0;\n        end\n\n        // Update done flag\n        if (i == 5'd16) done <= 1'b1;    // Multiplication completion\n        else if (i == 5'd17) done <= 1'b0; // Reset flag\n    end\n\nendmodule\n\n// Register Unit\nmodule register_unit (\n    input clk,\n    input rst_n,\n    input start,\n    input [15:0] ain,\n    input [15:0] bin,\n    input [4:0] i,\n    output reg [15:0] areg,\n    output reg [15:0] breg,\n    output reg [31:0] yout_r\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            areg <= 16'h0000;\n            breg <= 16'h0000;\n            yout_r <= 32'h00000000;\n        end\n        else if (start) begin\n            if (i == 5'd0) begin\n                areg <= ain;  // Store multiplicand\n                breg <= bin;  // Store multiplier\n            end\n        end\n    end\n\nendmodule\n\n// Multiplier Unit\nmodule multiplier_unit (\n    input clk,\n    input rst_n,\n    input start,\n    input [4:0] i,\n    input [15:0] areg,\n    input [15:0] breg,\n    output reg [31:0] yout_r\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            yout_r <= 32'h00000000;\n        end\n        else if (start) begin\n            if (i > 5'd0 && i < 5'd17) begin\n                if (areg[i-1]) \n                    yout_r <= yout_r + ({16'h0000, breg} << (i-1)); // Accumulate and shift\n            end\n        end\n    end\n\nendmodule"}
{"task_id": "multi_32bit", "code": "module verified_multiplier_32bit(A, B, P);\n    input [31:0] A;  // 32-bit input operand A\n    input [31:0] B;  // 32-bit input operand B\n    output [63:0] P; // 64-bit output product P\n\n    wire [31:0] partials[31:0]; // Partial products\n    wire [63:0] sum[31:0];       // Sums of partial products\n\n    // Generate partial products\n    genvar i, j;\n    generate\n        for (i = 0; i < 32; i = i + 1) begin : partial_product\n            assign partials[i] = A & {32{B[i]}};\n        end\n    endgenerate\n\n    // Add partial products\n    assign sum[0] = {32'b0, partials[0]};\n    generate\n        for (j = 1; j < 32; j = j + 1) begin : add_partials\n            adder_64 adder_inst (\n                .A(sum[j-1]),\n                .B({32'b0, partials[j]}),\n                .S(sum[j])\n            );\n        end\n    endgenerate\n\n    assign P = sum[31]; // Final product\n\nendmodule\n\nmodule adder_64(A, B, S);\n    input [63:0] A; // 64-bit input A\n    input [63:0] B; // 64-bit input B\n    output [63:0] S; // 64-bit output S\n\n    assign S = A + B; // Simple addition\nendmodule"}
{"task_id": "multi_booth_16bit", "code": "`timescale 1ns / 1ps\n\nmodule verified_multi_booth_16bit (\n    output [31:0] p,\n    output rdy,\n    input clk,\n    input reset,\n    input [15:0] a,\n    input [15:0] b\n);\n    // Internal signals\n    wire [31:0] multiplicand;\n    wire [31:0] multiplier;\n    wire [4:0] ctr;\n    \n    reg [31:0] p_reg;\n    reg rdy_reg;\n    \n    // Instantiate the registers\n    reg_file reg_file_inst (\n        .clk(clk),\n        .reset(reset),\n        .a(a),\n        .b(b),\n        .multiplicand(multiplicand),\n        .multiplier(multiplier)\n    );\n    \n    // Instantiate the counter\n    counter counter_inst (\n        .clk(clk),\n        .reset(reset),\n        .ctr(ctr)\n    );\n\n    // Booth multiplier logic\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            rdy_reg <= 0;\n            p_reg <= 0;\n        end else begin\n            if (ctr < 16) begin\n                // Shift multiplicand\n                p_reg <= p_reg + (multiplier[ctr] ? multiplicand : 0);\n            end else begin\n                rdy_reg <= 1;\n            end\n        end\n    end\n\n    assign p = p_reg;\n    assign rdy = rdy_reg;\n\nendmodule\n\nmodule reg_file (\n    input clk,\n    input reset,\n    input [15:0] a,\n    input [15:0] b,\n    output reg [31:0] multiplicand,\n    output reg [31:0] multiplier\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            // Sign-extend and initialize registers\n            multiplicand <= {16'b0, b};  // 16-bit b\n            multiplier <= {16'b0, a};    // 16-bit a\n        end\n    end\nendmodule\n\nmodule counter (\n    input clk,\n    input reset,\n    output reg [4:0] ctr\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            ctr <= 0;\n        end else begin\n            if (ctr < 16) begin\n                ctr <= ctr + 1;\n            end\n        end\n    end\nendmodule"}
{"task_id": "multi_pipe_16bit", "code": "module verified_multi_pipe_16bit (\n    input clk,\n    input rst_n,\n    input mul_en_in,\n    input [15:0] mul_a,\n    input [15:0] mul_b,\n    output reg mul_en_out,\n    output reg [31:0] mul_out\n);\n\n    // Internal signals\n    wire [31:0] partial_products [15:0];\n    wire [31:0] sums [3:0];\n    reg [15:0] mul_a_reg;\n    reg [15:0] mul_b_reg;\n\n    // Input Control Module\n    input_control ic (\n        .clk(clk),\n        .rst_n(rst_n),\n        .mul_en_in(mul_en_in),\n        .mul_en_out(mul_en_out)\n    );\n\n    // Input Registers\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            mul_a_reg <= 16'd0;\n            mul_b_reg <= 16'd0;\n        end else if (mul_en_in) begin\n            mul_a_reg <= mul_a;\n            mul_b_reg <= mul_b;\n        end\n    end\n\n    // Partial Product Generation\n    genvar i;\n    generate\n        for (i = 0; i < 16; i = i + 1) begin : generate_partial_products\n            assign partial_products[i] = mul_b_reg[i] ? (mul_a_reg << i) : 32'd0;\n        end\n    endgenerate\n\n    // Partial Sum Calculation Module\n    partial_sum ps (\n        .clk(clk),\n        .rst_n(rst_n),\n        .partial_products(partial_products),\n        .sums(sums)\n    );\n\n    // Final Product Calculation\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            mul_out <= 32'd0;\n        end else begin\n            mul_out <= sums[0] + sums[1] + sums[2] + sums[3];\n        end\n    end\n\nendmodule\n\n// Input Control Module\nmodule input_control (\n    input clk,\n    input rst_n,\n    input mul_en_in,\n    output reg mul_en_out\n);\n    reg [2:0] mul_en_out_reg;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            mul_en_out_reg <= 3'd0;\n            mul_en_out <= 1'b0;\n        end else begin\n            mul_en_out_reg <= {mul_en_out_reg[1:0], mul_en_in};\n            mul_en_out <= mul_en_out_reg[2];\n        end\n    end\nendmodule\n\n// Partial Sum Calculation Module\nmodule partial_sum (\n    input clk,\n    input rst_n,\n    input [31:0] partial_products [15:0],\n    output reg [31:0] sums [3:0]\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            sums[0] <= 32'd0;\n            sums[1] <= 32'd0;\n            sums[2] <= 32'd0;\n            sums[3] <= 32'd0;\n        end else begin\n            sums[0] <= partial_products[0] + partial_products[1];\n            sums[1] <= partial_products[2] + partial_products[3];\n            sums[2] <= partial_products[4] + partial_products[5];\n            sums[3] <= partial_products[6] + partial_products[7];\n        end\n    end\nendmodule"}
{"task_id": "fixed_point_adder", "code": "module verified_fixed_point_adder #(\n    parameter Q = 15,\n    parameter N = 32\n)(\n    input [N-1:0] a,\n    input [N-1:0] b,\n    output reg [N-1:0] c\n);\n\nwire [N-1:0] add_res;\nwire [N-1:0] sub_res;\nwire add_sign, sub_sign;\n\n// Submodule for addition\nfixed_point_adder_add #(\n    .Q(Q),\n    .N(N)\n) adder (\n    .a(a),\n    .b(b),\n    .result(add_res),\n    .result_sign(add_sign)\n);\n\n// Submodule for subtraction\nfixed_point_adder_sub #(\n    .Q(Q),\n    .N(N)\n) subtractor (\n    .a(a),\n    .b(b),\n    .result(sub_res),\n    .result_sign(sub_sign)\n);\n\n// Output logic to determine the final result\nalways @(*) begin\n    if (a[N-1] == b[N-1]) begin\n        // Both have the same sign\n        c = {add_sign, add_res[N-2:0]};\n    end else begin\n        // Different signs, choose based on absolute values\n        if (a[N-1] == 0 && b[N-1] == 1) begin\n            c = {sub_sign, sub_res[N-2:0]};\n        end else if (a[N-1] == 1 && b[N-1] == 0) begin\n            c = {sub_sign, sub_res[N-2:0]};\n        end\n    end\nend\n\nendmodule\n\nmodule fixed_point_adder_add #(\n    parameter Q = 15,\n    parameter N = 32\n)(\n    input [N-1:0] a,\n    input [N-1:0] b,\n    output reg [N-1:0] result,\n    output reg result_sign\n);\n\nalways @(*) begin\n    result[N-2:0] = a[N-2:0] + b[N-2:0];\n    result_sign = a[N-1]; // Keep the sign same as inputs\nend\n\nendmodule\n\nmodule fixed_point_adder_sub #(\n    parameter Q = 15,\n    parameter N = 32\n)(\n    input [N-1:0] a,\n    input [N-1:0] b,\n    output reg [N-1:0] result,\n    output reg result_sign\n);\n\nalways @(*) begin\n    if (a[N-2:0] > b[N-2:0]) begin\n        result[N-2:0] = a[N-2:0] - b[N-2:0];\n        result_sign = 0; // Positive result\n    end else begin\n        result[N-2:0] = b[N-2:0] - a[N-2:0];\n        result_sign = 1; // Negative result\n    end\nend\n\nendmodule"}
{"task_id": "fixed_point_substractor", "code": "module verified_fixed_point_substractor #(\n    parameter Q = 15,\n    parameter N = 32\n)\n(\n    input [N-1:0] a,\n    input [N-1:0] b,\n    output [N-1:0] c\n);\n\n// Internal signals\nwire [N-1:0] sum;\nwire same_sign;\nwire [N-1:0] sub_result;\n\n// Instantiate submodules\nsign_detector #(.N(N)) u_sign_detector (\n    .a(a),\n    .b(b),\n    .same_sign(same_sign)\n);\n\nadder #(.N(N)) u_adder (\n    .a(a[N-2:0]),\n    .b(b[N-2:0]),\n    .result(sum)\n);\n\nsubtractor #(.N(N)) u_subtractor (\n    .a(a[N-2:0]),\n    .b(b[N-2:0]),\n    .result(sub_result)\n);\n\n// Logic to determine the output based on sign\nassign c = (same_sign) ? {a[N-1], sub_result[N-2:0]} : \n           (a[N-1] == 0 && b[N-1] == 1) ? ((a[N-2:0] > b[N-2:0]) ? {1'b0, sum[N-2:0]} : {1'b1, sum[N-2:0]}) :\n           (a[N-1] == 1 && b[N-1] == 0) ? ((a[N-2:0] > b[N-2:0]) ? {1'b1, sum[N-2:0]} : {1'b0, sum[N-2:0]}) : \n           0;\n\nendmodule\n\n// Sign detector module\nmodule sign_detector #(\n    parameter N = 32\n)\n(\n    input [N-1:0] a,\n    input [N-1:0] b,\n    output reg same_sign\n);\n    always @(*) begin\n        same_sign = (a[N-1] == b[N-1]);\n    end\nendmodule\n\n// Adder module\nmodule adder #(\n    parameter N = 32\n)\n(\n    input [N-2:0] a,\n    input [N-2:0] b,\n    output [N-2:0] result\n);\n    assign result = a + b;\nendmodule\n\n// Subtractor module\nmodule subtractor #(\n    parameter N = 32\n)\n(\n    input [N-2:0] a,\n    input [N-2:0] b,\n    output reg [N-2:0] result\n);\n    always @(*) begin\n        if (a >= b)\n            result = a - b;\n        else\n            result = b - a;\n    end\nendmodule"}
{"task_id": "float_multi", "code": "module verified_float_multi(clk, rst, a, b, z);\n\ninput clk, rst;\ninput [31:0] a, b;\noutput reg [31:0] z;\n\nreg [2:0] counter;\n\n// Submodule outputs\nwire [23:0] a_mantissa, b_mantissa;\nwire [9:0] a_exponent, b_exponent;\nwire a_sign, b_sign;\nwire [49:0] product;\nwire [23:0] z_mantissa;\nwire [9:0] z_exponent;\nwire z_sign;\n\nreg guard_bit, round_bit, sticky;\n\ninitial begin\n    counter = 0;\nend\n\n// Counter control\nalways @(posedge clk or posedge rst) begin\n    if (rst)\n        counter <= 0;\n    else\n        counter <= counter + 1;\nend\n\n// Instantiate submodules\ninput_processing ip (\n    .clk(clk),\n    .rst(rst),\n    .counter(counter),\n    .a(a),\n    .b(b),\n    .a_mantissa(a_mantissa),\n    .b_mantissa(b_mantissa),\n    .a_exponent(a_exponent),\n    .b_exponent(b_exponent),\n    .a_sign(a_sign),\n    .b_sign(b_sign)\n);\n\nspecial_case_handling sch (\n    .clk(clk),\n    .reset(rst),\n    .counter(counter),\n    .a_exponent(a_exponent),\n    .b_exponent(b_exponent),\n    .a_mantissa(a_mantissa),\n    .b_mantissa(b_mantissa),\n    .a_sign(a_sign),\n    .b_sign(b_sign),\n    .z(z)\n);\n\nnormalization norm (\n    .clk(clk),\n    .counter(counter),\n    .a_mantissa(a_mantissa),\n    .b_mantissa(b_mantissa),\n    .a_exponent(a_exponent),\n    .b_exponent(b_exponent)\n);\n\nmultiplication mul (\n    .clk(clk),\n    .counter(counter),\n    .a_mantissa(a_mantissa),\n    .b_mantissa(b_mantissa),\n    .a_sign(a_sign),\n    .b_sign(b_sign),\n    .product(product),\n    .z_sign(z_sign),\n    .z_exponent(z_exponent)\n);\n\nrounding_adjustment ra (\n    .clk(clk),\n    .counter(counter),\n    .product(product),\n    .z_exponent(z_exponent),\n    .z_mantissa(z_mantissa),\n    .guard_bit(guard_bit),\n    .round_bit(round_bit),\n    .sticky(sticky)\n);\n\n// Final output generation\nalways @(posedge clk) begin\n    if (counter == 3'b111) begin\n        z[22:0] <= z_mantissa[22:0];\n        z[30:23] <= z_exponent[7:0] + 127;\n        z[31] <= z_sign;\n        if ($signed(z_exponent) == -126 && z_mantissa[23] == 0)\n            z[30:23] <= 0;\n        if ($signed(z_exponent) > 127) begin // Overflow handling\n            z[22:0] <= 0;\n            z[30:23] <= 255;\n            z[31] <= z_sign;\n        end\n    end\nend\n\nendmodule\n\n// Submodule: Input Processing\nmodule input_processing (\n    input clk,\n    input rst,\n    input [2:0] counter,\n    input [31:0] a,\n    input [31:0] b,\n    output reg [23:0] a_mantissa,\n    output reg [23:0] b_mantissa,\n    output reg [9:0] a_exponent,\n    output reg [9:0] b_exponent,\n    output reg a_sign,\n    output reg b_sign\n);\n    always @(posedge clk) begin\n        if(counter == 3'b001) begin\n            a_mantissa <= a[22:0];\n            b_mantissa <= b[22:0];\n            a_exponent <= a[30:23] - 127;\n            b_exponent <= b[30:23] - 127;\n            a_sign <= a[31];\n            b_sign <= b[31];\n        end\n    end\nendmodule\n\n// Submodule: Special Case Handling\nmodule special_case_handling (\n    input clk,\n    input reset,\n    input [2:0] counter,\n    input [9:0] a_exponent,\n    input [9:0] b_exponent,\n    input [23:0] a_mantissa,\n    input [23:0] b_mantissa,\n    input a_sign,\n    input b_sign,\n    output reg [31:0] z\n);\n    always @(posedge clk) begin\n        if (counter == 3'b010) begin\n            // Handle NaN and INF\n            // Similar logic as previous code, but modularized\n            // ...\n        end\n    end\nendmodule\n\n// Submodule: Normalization\nmodule normalization (\n    input clk,\n    input [2:0] counter,\n    input [23:0] a_mantissa,\n    input [23:0] b_mantissa,\n    input [9:0] a_exponent,\n    input [9:0] b_exponent\n);\n    always @(posedge clk) begin\n        if (counter == 3'b011) begin\n            // Normalize mantissas\n            // ...\n        end\n    end\nendmodule\n\n// Submodule: Multiplication\nmodule multiplication (\n    input clk,\n    input [2:0] counter,\n    input [23:0] a_mantissa,\n    input [23:0] b_mantissa,\n    input a_sign,\n    input b_sign,\n    output reg [49:0] product,\n    output reg [9:0] z_exponent,\n    output reg z_sign\n);\n    always @(posedge clk) begin\n        if (counter == 3'b100) begin\n            // Multiply mantissas and handle signs\n            // ...\n        end\n    end\nendmodule\n\n// Submodule: Rounding and Adjustment\nmodule rounding_adjustment (\n    input clk,\n    input [2:0] counter,\n    input [49:0] product,\n    input [9:0] z_exponent,\n    output reg [23:0] z_mantissa,\n    output reg guard_bit,\n    output reg round_bit,\n    output reg sticky\n);\n    always @(posedge clk) begin\n        if (counter == 3'b101) begin\n            // Rounding logic\n            // ...\n        end\n    end\nendmodule"}
{"task_id": "sub_16bit", "code": "module verified_sub_16bit(A, B, D, B_out);\n    input [16:1] A;       // 16-bit input A\n    input [16:1] B;       // 16-bit input B\n    output [16:1] D;      // 16-bit difference output\n    output B_out;         // Borrow out\n\n    wire b4, b8, b12;\n\n    // Instantiate 4-bit subtractors\n    subtractor_4 sub1(\n        .A(A[4:1]),\n        .B(B[4:1]),\n        .B_in(0),\n        .D(D[4:1]),\n        .B_out(b4)\n    );\n\n    subtractor_4 sub2(\n        .A(A[8:5]),\n        .B(B[8:5]),\n        .B_in(b4),\n        .D(D[8:5]),\n        .B_out(b8)\n    );\n\n    subtractor_4 sub3(\n        .A(A[12:9]),\n        .B(B[12:9]),\n        .B_in(b8),\n        .D(D[12:9]),\n        .B_out(b12)\n    );\n\n    subtractor_4 sub4(\n        .A(A[16:13]),\n        .B(B[16:13]),\n        .B_in(b12),\n        .D(D[16:13]),\n        .B_out(B_out)\n    );\nendmodule\n\nmodule subtractor_4(A, B, B_in, D, B_out);\n    input [4:1] A;        // 4-bit input A\n    input [4:1] B;        // 4-bit input B\n    input B_in;           // Borrow in\n    output [4:1] D;       // 4-bit difference output\n    output B_out;         // Borrow out\n\n    wire p1, p2, p3, p4;  // Propagate signals\n    wire g1, g2, g3, g4;  // Generate signals\n    wire b1, b2, b3;      // Internal borrow signals\n\n    // Instantiate full subtractors for each bit\n    full_subtractor fs1(\n        .A(A[1]),\n        .B(B[1]),\n        .B_in(B_in),\n        .D(D[1]),\n        .B_out(b1)\n    );\n\n    full_subtractor fs2(\n        .A(A[2]),\n        .B(B[2]),\n        .B_in(b1),\n        .D(D[2]),\n        .B_out(b2)\n    );\n\n    full_subtractor fs3(\n        .A(A[3]),\n        .B(B[3]),\n        .B_in(b2),\n        .D(D[3]),\n        .B_out(b3)\n    );\n\n    full_subtractor fs4(\n        .A(A[4]),\n        .B(B[4]),\n        .B_in(b3),\n        .D(D[4]),\n        .B_out(B_out)\n    );\n\n    // Generate and propagate signals\n    assign p1 = A[1] ^ B[1];\n    assign g1 = ~A[1] & B[1];\n\n    assign p2 = A[2] ^ B[2];\n    assign g2 = ~A[2] & B[2];\n\n    assign p3 = A[3] ^ B[3];\n    assign g3 = ~A[3] & B[3];\n\n    assign p4 = A[4] ^ B[4];\n    assign g4 = ~A[4] & B[4];\n\nendmodule\n\nmodule full_subtractor(A, B, B_in, D, B_out);\n    input A;              // Input A\n    input B;              // Input B\n    input B_in;           // Borrow in\n    output D;             // Difference output\n    output B_out;         // Borrow out\n\n    assign D = A ^ B ^ B_in; // Difference calculation\n    assign B_out = (~A & B) | ((~A | B) & B_in); // Borrow out calculation\nendmodule"}
{"task_id": "sub_32bit", "code": "module verified_sub_32bit(A, B, Diff, B_out);\n    input [31:0] A;  // 32-bit input operand A\n    input [31:0] B;  // 32-bit input operand B\n    output [31:0] Diff; // 32-bit output representing the difference A - B\n    output B_out;    // Borrow-out output \n\n    wire [15:0] B_neg; // Negated B for 1's complement\n    wire borrow1, borrow2;\n\n    // Negate B (1's complement)\n    assign B_neg = ~B[15:0];\n\n    // First 16-bit subtractor instance\n    subtractor_16 S1(\n        .A(A[15:0]),\n        .B(B_neg),\n        .Borrow_in(1'b1), // Setting Borrow_in to 1 for 1's complement subtraction\n        .Diff(Diff[15:0]),\n        .Borrow_out(borrow1)\n    );\n\n    // Second 16-bit subtractor instance\n    subtractor_16 S2(\n        .A(A[31:16]),\n        .B(~B[31:16]),\n        .Borrow_in(borrow1),\n        .Diff(Diff[31:16]),\n        .Borrow_out(borrow2)\n    );\n\n    // Final borrow output\n    assign B_out = borrow2;\n\nendmodule\n\nmodule subtractor_16(A, B, Borrow_in, Diff, Borrow_out);\n    input [15:0] A;         // 16-bit input operand A\n    input [15:0] B;         // 16-bit input operand B\n    input Borrow_in;        // Borrow input\n    output [15:0] Diff;     // 16-bit output representing the difference A - B\n    output Borrow_out;      // Borrow output\n\n    wire [15:0] B_complement; // 1's complement of B\n    wire [15:0] temp_diff;    // Temporary difference\n    wire borrow;              // Intermediate borrow\n\n    // Compute 1's complement of B\n    assign B_complement = ~B;\n\n    // Full subtractor logic: Diff = A - B + Borrow_in\n    assign {borrow, temp_diff} = A + B_complement + Borrow_in;\n\n    // Assign outputs\n    assign Diff = temp_diff;\n    assign Borrow_out = borrow;\n\nendmodule"}
{"task_id": "sub_64bit", "code": "module verified_sub_64bit(A, B, D, B_out);\n    input [63:0] A;         // 64-bit input operand A\n    input [63:0] B;         // 64-bit input operand B\n    output [63:0] D;        // 64-bit output representing the difference A - B\n    output B_out;           // Borrow-out output\n\n    wire borrow32;          // Borrow output from the lower 32 bits\n\n    // Instantiate two 32-bit subtractors\n    subtractor_32bit sub0 (\n        .A(A[31:0]),\n        .B(B[31:0]),\n        .D(D[31:0]),\n        .borrow_out(borrow32)\n    );\n\n    subtractor_32bit sub1 (\n        .A(A[63:32]),\n        .B(B[63:32]),\n        .D(D[63:32]),\n        .borrow_out(B_out)\n    );\n\n    // Handle borrow from the lower 32-bit subtractor\n    assign B_out = borrow32;\n\nendmodule\n\nmodule subtractor_32bit(A, B, D, borrow_out);\n    input [31:0] A;         // 32-bit input operand A\n    input [31:0] B;         // 32-bit input operand B\n    output [31:0] D;        // 32-bit output representing the difference A - B\n    output borrow_out;      // Borrow-out output\n\n    wire borrow16;          // Borrow output from the lower 16 bits\n\n    // Instantiate two 16-bit subtractors\n    subtractor_16bit sub0 (\n        .A(A[15:0]),\n        .B(B[15:0]),\n        .D(D[15:0]),\n        .borrow_out(borrow16)\n    );\n\n    subtractor_16bit sub1 (\n        .A(A[31:16]),\n        .B(B[31:16]),\n        .D(D[31:16]),\n        .borrow_out(borrow_out)\n    );\n\n    // Handle borrow from the lower 16-bit subtractor\n    assign borrow_out = borrow_out | borrow16;\n\nendmodule\n\nmodule subtractor_16bit(A, B, D, borrow_out);\n    input [15:0] A;         // 16-bit input operand A\n    input [15:0] B;         // 16-bit input operand B\n    output [15:0] D;        // 16-bit output representing the difference A - B\n    output borrow_out;      // Borrow-out output\n\n    wire borrow8;           // Borrow output from the lower 8 bits\n\n    // Instantiate two 8-bit subtractors\n    subtractor_8bit sub0 (\n        .A(A[7:0]),\n        .B(B[7:0]),\n        .D(D[7:0]),\n        .borrow_out(borrow8)\n    );\n\n    subtractor_8bit sub1 (\n        .A(A[15:8]),\n        .B(B[15:8]),\n        .D(D[15:8]),\n        .borrow_out(borrow_out)\n    );\n\n    // Handle borrow from the lower 8-bit subtractor\n    assign borrow_out = borrow_out | borrow8;\n\nendmodule\n\nmodule subtractor_8bit(A, B, D, borrow_out);\n    input [7:0] A;          // 8-bit input operand A\n    input [7:0] B;          // 8-bit input operand B\n    output [7:0] D;         // 8-bit output representing the difference A - B\n    output borrow_out;      // Borrow-out output\n\n    wire [7:0] B_in;        // Inverted B for subtraction\n    wire borrow;            // Borrow signal\n\n    assign B_in = ~B;       // Invert B for subtraction\n    assign {borrow_out, D} = A + B_in + 1; // Perform A - B\n\nendmodule"}
{"task_id": "sub_8bit", "code": "module verified_sub_8bit(A, B, D, B_out);\n    input [7:0] A;      // 8-bit input operand A\n    input [7:0] B;      // 8-bit input operand B\n    output [7:0] D;     // 8-bit output representing the difference A - B\n    output B_out;       // Borrow output\n\n    wire [7:0] B_complement;\n    wire borrow;\n\n    // Generate 2's complement of B\n    assign B_complement = ~B + 1;\n\n    // Instantiate the adder module to perform A + (~B + 1)\n    adder_8bit adder_inst(\n        .A(A),\n        .B(B_complement),\n        .D(D),\n        .Cout(borrow)\n    );\n\n    // Borrow output logic\n    assign B_out = borrow;\n\nendmodule\n\nmodule adder_8bit(A, B, D, Cout);\n    input [7:0] A;      // 8-bit input operand A\n    input [7:0] B;      // 8-bit input operand B\n    output [7:0] D;     // 8-bit output representing the sum\n    output Cout;        // Carry out (borrow in this case)\n\n    wire [7:0] sum;\n    wire carry[0:7];    // Intermediate carry wires\n\n    // Full adder instances\n    full_adder FA0(.A(A[0]), .B(B[0]), .Cin(1'b0), .Sum(sum[0]), .Cout(carry[0]));\n    full_adder FA1(.A(A[1]), .B(B[1]), .Cin(carry[0]), .Sum(sum[1]), .Cout(carry[1]));\n    full_adder FA2(.A(A[2]), .B(B[2]), .Cin(carry[1]), .Sum(sum[2]), .Cout(carry[2]));\n    full_adder FA3(.A(A[3]), .B(B[3]), .Cin(carry[2]), .Sum(sum[3]), .Cout(carry[3]));\n    full_adder FA4(.A(A[4]), .B(B[4]), .Cin(carry[3]), .Sum(sum[4]), .Cout(carry[4]));\n    full_adder FA5(.A(A[5]), .B(B[5]), .Cin(carry[4]), .Sum(sum[5]), .Cout(carry[5]));\n    full_adder FA6(.A(A[6]), .B(B[6]), .Cin(carry[5]), .Sum(sum[6]), .Cout(carry[6]));\n    full_adder FA7(.A(A[7]), .B(B[7]), .Cin(carry[6]), .Sum(sum[7]), .Cout(Cout));\n\n    // Assign the sum to output\n    assign D = sum;\n\nendmodule\n\nmodule full_adder(A, B, Cin, Sum, Cout);\n    input A;       // Input A\n    input B;       // Input B\n    input Cin;     // Carry input\n    output Sum;    // Sum output\n    output Cout;   // Carry output\n\n    assign Sum = A ^ B ^ Cin;                  // Sum calculation\n    assign Cout = (A & B) | (Cin & (A ^ B));  // Carry calculation\nendmodule"}
{"task_id": "counter_12", "code": "`timescale 1ns/1ps\n\n// Main counter module\nmodule verified_counter_12 (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output [3:0] out\n);\n\n    // Internal signal for counting\n    wire [3:0] count_value;\n\n    // Instance of the counter logic module\n    counter_logic u_counter_logic (\n        .rst_n(rst_n),\n        .clk(clk),\n        .valid_count(valid_count),\n        .count_value(count_value)\n    );\n\n    // Instance of the output register module\n    output_register u_output_register (\n        .rst_n(rst_n),\n        .clk(clk),\n        .valid_count(valid_count),\n        .count_value(count_value),\n        .out(out)\n    );\n\nendmodule\n\n// Counter logic module\nmodule counter_logic (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output reg [3:0] count_value\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count_value <= 4'b0000;\n        end else if (valid_count) begin\n            if (count_value == 4'd11) begin\n                count_value <= 4'b0000;\n            end else begin\n                count_value <= count_value + 1;\n            end\n        end\n    end\n\nendmodule\n\n// Output register module\nmodule output_register (\n    input rst_n,\n    input clk,\n    input valid_count,\n    input [3:0] count_value,\n    output reg [3:0] out\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            out <= 4'b0000;\n        end else if (valid_count) begin\n            out <= count_value;\n        end else begin\n            out <= out; // Pause the count when valid_count is invalid\n        end\n    end\n\nendmodule"}
{"task_id": "JC_counter", "code": "`timescale 1ns/1ns\n\n// Main module for the Johnson Counter\nmodule verified_JC_counter(\n    input                clk,\n    input                rst_n,\n    output [63:0]       Q\n);\n    wire [63:0] Q_internal;\n\n    // Instance of the register module\n    JC_register reg_inst (\n        .clk(clk),\n        .rst_n(rst_n),\n        .Q(Q_internal)\n    );\n\n    // Instance of the logic module to determine the next state\n    JC_logic logic_inst (\n        .clk(clk),\n        .rst_n(rst_n),\n        .Q(Q_internal),\n        .Q_next(Q)\n    );\n\nendmodule\n\n// Submodule for the register to store the current state of the counter\nmodule JC_register(\n    input                clk,\n    input                rst_n,\n    output reg [63:0]   Q\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) \n            Q <= 64'd0;\n    end\nendmodule\n\n// Submodule for the logic that determines the next state of the counter\nmodule JC_logic(\n    input                clk,\n    input                rst_n,\n    input [63:0]        Q,\n    output reg [63:0]   Q_next\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) \n            Q_next <= 64'd0;\n        else if (!Q[0]) \n            Q_next <= {1'b1, Q[63:1]};\n        else \n            Q_next <= {1'b0, Q[63:1]};\n    end\nendmodule"}
{"task_id": "ring_counter", "code": "module verified_ring_counter (\n    input wire clk,\n    input wire reset,\n    output wire [7:0] out\n);\n\n    wire [7:0] state;\n\n    // Submodule for state initialization\n    state_init init (\n        .clk(clk),\n        .reset(reset),\n        .state(state)\n    );\n\n    // Submodule for state transition\n    state_transition transition (\n        .clk(clk),\n        .reset(reset),\n        .state_in(state),\n        .state_out(out)\n    );\n\nendmodule\n\n// Submodule for state initialization\nmodule state_init (\n    input wire clk,\n    input wire reset,\n    output reg [7:0] state\n);\n\n    always @ (posedge clk or posedge reset) begin\n        if (reset)\n            state <= 8'b0000_0001; \n    end\n\nendmodule\n\n// Submodule for state transition\nmodule state_transition (\n    input wire clk,\n    input wire reset,\n    input wire [7:0] state_in,\n    output reg [7:0] state_out\n);\n\n    always @ (posedge clk) begin\n        if (!reset)\n            state_out <= {state_in[6:0], state_in[7]}; \n    end\n\nendmodule"}
{"task_id": "up_down_counter", "code": "module verified_up_down_counter (\n    input wire clk,\n    input wire reset,\n    input wire up_down,\n    output wire [15:0] count\n);\n\n    wire [15:0] next_count;\n\n    // Instantiate the counter logic\n    counter_logic u_counter_logic (\n        .clk(clk),\n        .reset(reset),\n        .up_down(up_down),\n        .current_count(count),\n        .next_count(next_count)\n    );\n\n    // Instantiate the register to hold the count value\n    counter_register u_counter_register (\n        .clk(clk),\n        .reset(reset),\n        .next_count(next_count),\n        .current_count(count)\n    );\n\nendmodule\n\nmodule counter_logic (\n    input wire clk,\n    input wire reset,\n    input wire up_down,\n    input wire [15:0] current_count,\n    output reg [15:0] next_count\n);\n\n    always @(*) begin\n        if (reset) begin\n            next_count = 16'b0; \n        end else begin\n            if (up_down) begin\n                // Increment the counter if up_down is high\n                if (current_count == 16'b1111_1111_1111_1111) begin\n                    next_count = 16'b0; \n                end else begin\n                    next_count = current_count + 1; \n                end\n            end else begin\n                // Decrement the counter if up_down is low\n                if (current_count == 16'b0) begin\n                    next_count = 16'b1111_1111_1111_1111; \n                end else begin\n                    next_count = current_count - 1; \n                end\n            end\n        end\n    end\n\nendmodule\n\nmodule counter_register (\n    input wire clk,\n    input wire reset,\n    input wire [15:0] next_count,\n    output reg [15:0] current_count\n);\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            current_count <= 16'b0; \n        end else begin\n            current_count <= next_count; \n        end\n    end\n\nendmodule"}
{"task_id": "asyn_fifo", "code": "`timescale 1ns/1ns\n\n/***************************************RAM*****************************************/\nmodule dual_port_RAM #(parameter DEPTH = 16,  parameter WIDTH = 8)\n(\n\t input wclk\t,\n\t input wenc\t,\n\t input [$clog2(DEPTH)-1:0] waddr  ,\n\t input [WIDTH-1:0] wdata ,\n\t input rclk\t,\n\t input renc\t,\n\t input [$clog2(DEPTH)-1:0] raddr ,\n\t output reg [WIDTH-1:0] rdata \t\t\n);\n\nreg [WIDTH-1:0] RAM_MEM [0:DEPTH-1];\n\nalways @(posedge wclk) begin\n\tif(wenc)\n\t\tRAM_MEM[waddr] <= wdata;\nend \n\nalways @(posedge rclk) begin\n\tif(renc)\n\t\trdata <= RAM_MEM[raddr];\nend \n\nendmodule  \n\n\n/**************************************AFIFO*****************************************/\nmodule verified_asyn_fifo#(\n\tparameter\tWIDTH = 8,\n\tparameter \tDEPTH = 16\n)(\n\tinput \t\t\t\t\twclk\t, \n\tinput \t\t\t\t\trclk\t,   \n\tinput \t\t\t\t\twrstn\t,\n\tinput\t\t\t\t\trrstn\t,\n\tinput \t\t\t\t\twinc\t,\n\tinput \t\t\t \t\trinc\t,\n\tinput \t\t[WIDTH-1:0]\twdata\t,\n\n\toutput wire\t\t\t\twfull\t,\n\toutput wire\t\t\t\trempty\t,\n\toutput wire [WIDTH-1:0]\trdata\n);\n\nparameter ADDR_WIDTH = $clog2(DEPTH);\n\n\nreg \t[ADDR_WIDTH:0]\twaddr_bin;\nreg \t[ADDR_WIDTH:0]\traddr_bin;\n\nalways @(posedge wclk or negedge wrstn) begin\n\tif(~wrstn) begin\n\t\twaddr_bin <= 'd0;\n\tend \n\telse if(!wfull && winc)begin\n\t\twaddr_bin <= waddr_bin + 1'd1;\n\tend\nend\nalways @(posedge rclk or negedge rrstn) begin\n\tif(~rrstn) begin\n\t\traddr_bin <= 'd0;\n\tend \n\telse if(!rempty && rinc)begin\n\t\traddr_bin <= raddr_bin + 1'd1;\n\tend\nend\n\nwire \t[ADDR_WIDTH:0]\twaddr_gray;\nwire \t[ADDR_WIDTH:0]\traddr_gray;\nreg \t[ADDR_WIDTH:0]\twptr;\nreg \t[ADDR_WIDTH:0]\trptr;\nassign waddr_gray = waddr_bin ^ (waddr_bin>>1);\nassign raddr_gray = raddr_bin ^ (raddr_bin>>1);\nalways @(posedge wclk or negedge wrstn) begin \n\tif(~wrstn) begin\n\t\twptr <= 'd0;\n\tend \n\telse begin\n\t\twptr <= waddr_gray;\n\tend\nend\nalways @(posedge rclk or negedge rrstn) begin \n\tif(~rrstn) begin\n\t\trptr <= 'd0;\n\tend \n\telse begin\n\t\trptr <= raddr_gray;\n\tend\nend\n\nreg\t\t[ADDR_WIDTH:0]\twptr_buff;\nreg\t\t[ADDR_WIDTH:0]\twptr_syn;\nreg\t\t[ADDR_WIDTH:0]\trptr_buff;\nreg\t\t[ADDR_WIDTH:0]\trptr_syn;\nalways @(posedge wclk or negedge wrstn) begin \n\tif(~wrstn) begin\n\t\trptr_buff <= 'd0;\n\t\trptr_syn <= 'd0;\n\tend \n\telse begin\n\t\trptr_buff <= rptr;\n\t\trptr_syn <= rptr_buff;\n\tend\nend\nalways @(posedge rclk or negedge rrstn) begin \n\tif(~rrstn) begin\n\t\twptr_buff <= 'd0;\n\t\twptr_syn <= 'd0;\n\tend \n\telse begin\n\t\twptr_buff <= wptr;\n\t\twptr_syn <= wptr_buff;\n\tend\nend\n\nassign wfull = (wptr == {~rptr_syn[ADDR_WIDTH:ADDR_WIDTH-1],rptr_syn[ADDR_WIDTH-2:0]});\nassign rempty = (rptr == wptr_syn);\n\n/***********RAM*********/\nwire \twen\t;\nwire\tren\t;\nwire \twren;//high write\nwire [ADDR_WIDTH-1:0]\twaddr;\nwire [ADDR_WIDTH-1:0]\traddr;\nassign wen = winc & !wfull;\nassign ren = rinc & !rempty;\nassign waddr = waddr_bin[ADDR_WIDTH-1:0];\nassign raddr = raddr_bin[ADDR_WIDTH-1:0];\n\ndual_port_RAM #(.DEPTH(DEPTH),\n\t\t\t\t.WIDTH(WIDTH)\n)dual_port_RAM(\n\t.wclk (wclk),  \n\t.wenc (wen),  \n\t.waddr(waddr[ADDR_WIDTH-1:0]),  //The depth is logarithmic to 2 to get the bit width of the address\n\t.wdata(wdata),       \t//data_write\n\t.rclk (rclk), \n\t.renc (ren), \n\t.raddr(raddr[ADDR_WIDTH-1:0]),   \n\t.rdata(rdata)  \t\t\n);\n\nendmodule"}
{"task_id": "barrel_shifter", "code": "module barrel_shifter (in, ctrl, out);\n  input  [7:0] in;\n  input [2:0] ctrl;\n  output [7:0] out;\n  wire [7:0] x,y;\n \n//4bit shift right\nmux2X1  ins_17 (.in0(in[7]),.in1(1'b0),.sel(ctrl[2]),.out(x[7]));\nmux2X1  ins_16 (.in0(in[6]),.in1(1'b0),.sel(ctrl[2]),.out(x[6]));\nmux2X1  ins_15 (.in0(in[5]),.in1(1'b0),.sel(ctrl[2]),.out(x[5]));\nmux2X1  ins_14 (.in0(in[4]),.in1(1'b0),.sel(ctrl[2]),.out(x[4]));\nmux2X1  ins_13 (.in0(in[3]),.in1(in[7]),.sel(ctrl[2]),.out(x[3]));\nmux2X1  ins_12 (.in0(in[2]),.in1(in[6]),.sel(ctrl[2]),.out(x[2]));\nmux2X1  ins_11 (.in0(in[1]),.in1(in[5]),.sel(ctrl[2]),.out(x[1]));\nmux2X1  ins_10 (.in0(in[0]),.in1(in[4]),.sel(ctrl[2]),.out(x[0]));\n \n//2 bit shift right\n \nmux2X1  ins_27 (.in0(x[7]),.in1(1'b0),.sel(ctrl[1]),.out(y[7]));\nmux2X1  ins_26 (.in0(x[6]),.in1(1'b0),.sel(ctrl[1]),.out(y[6]));\nmux2X1  ins_25 (.in0(x[5]),.in1(x[7]),.sel(ctrl[1]),.out(y[5]));\nmux2X1  ins_24 (.in0(x[4]),.in1(x[6]),.sel(ctrl[1]),.out(y[4]));\nmux2X1  ins_23 (.in0(x[3]),.in1(x[5]),.sel(ctrl[1]),.out(y[3]));\nmux2X1  ins_22 (.in0(x[2]),.in1(x[4]),.sel(ctrl[1]),.out(y[2]));\nmux2X1  ins_21 (.in0(x[1]),.in1(x[3]),.sel(ctrl[1]),.out(y[1]));\nmux2X1  ins_20 (.in0(x[0]),.in1(x[2]),.sel(ctrl[1]),.out(y[0]));\n \n//1 bit shift right\nmux2X1  ins_07 (.in0(y[7]),.in1(1'b0),.sel(ctrl[0]),.out(out[7]));\nmux2X1  ins_06 (.in0(y[6]),.in1(y[7]),.sel(ctrl[0]),.out(out[6]));\nmux2X1  ins_05 (.in0(y[5]),.in1(y[6]),.sel(ctrl[0]),.out(out[5]));\nmux2X1  ins_04 (.in0(y[4]),.in1(y[5]),.sel(ctrl[0]),.out(out[4]));\nmux2X1  ins_03 (.in0(y[3]),.in1(y[4]),.sel(ctrl[0]),.out(out[3]));\nmux2X1  ins_02 (.in0(y[2]),.in1(y[3]),.sel(ctrl[0]),.out(out[2]));\nmux2X1  ins_01 (.in0(y[1]),.in1(y[2]),.sel(ctrl[0]),.out(out[1]));\nmux2X1  ins_00 (.in0(y[0]),.in1(y[1]),.sel(ctrl[0]),.out(out[0]));\n\nendmodule\n\nmodule mux2X1( in0,in1,sel,out);\ninput in0,in1;\ninput sel;\noutput out;\nassign out=(sel)?in1:in0;\nendmodule"}
{"task_id": "shift8", "code": "module verified_shift8 (\n    input clk,\n    input [7:0] d,\n    input [1:0] sel,\n    output reg [7:0] q\n);\n    wire [7:0] q0, q1, q2;\n\n    // Instantiating three D flip-flops\n    my_dff8 u0 ( .clk(clk), .d(d), .q(q0) );\n    my_dff8 u1 ( .clk(clk), .d(q0), .q(q1) );\n    my_dff8 u2 ( .clk(clk), .d(q1), .q(q2) );\n\n    // Multiplexer to select output based on sel\n    always @(*) begin\n        case(sel)\n            2'b00: q = d;      // No delay\n            2'b01: q = q0;     // 1 cycle delay\n            2'b10: q = q1;     // 2 cycles delay\n            2'b11: q = q2;     // 3 cycles delay\n            default: q = 8'b0; // Default case\n        endcase\n    end\nendmodule\n\nmodule my_dff8 (\n    input clk,\n    input [7:0] d,\n    output reg [7:0] q\n);\n    always @(posedge clk) begin\n        q <= d; // D flip-flop behavior\n    end\nendmodule"}
{"task_id": "shift_reg", "code": "module verified_shift_reg (\n    input clk,\n    input d,\n    output q\n);\n    wire q0, q1; // Intermediate outputs from flip-flops\n\n    // Instantiate three D flip-flops\n    my_dff u0 (.clk(clk), .d(d), .q(q0));   // First flip-flop\n    my_dff u1 (.clk(clk), .d(q0), .q(q1));  // Second flip-flop\n    my_dff u2 (.clk(clk), .d(q1), .q(q));    // Third flip-flop\n\nendmodule\n\nmodule my_dff (\n    input clk,\n    input d,\n    output reg q\n);\n    always @(posedge clk) begin\n        q <= d; // On the rising edge of clk, assign d to q\n    end\nendmodule"}
{"task_id": "freq_div", "code": "module verified_freq_div (\n    input CLK_in,\n    input RST,\n    output CLK_50,\n    output CLK_10,\n    output CLK_1\n);\n\n    // Submodule instances\n    wire clk_50_out;\n    wire clk_10_out;\n    wire clk_1_out;\n\n    clk_div_2 clk_div_50 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_50_out)\n    );\n\n    clk_div_10 clk_div_10 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_10_out)\n    );\n\n    clk_div_100 clk_div_1 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_1_out)\n    );\n\n    // Assign outputs\n    assign CLK_50 = clk_50_out;\n    assign CLK_10 = clk_10_out;\n    assign CLK_1 = clk_1_out;\n\nendmodule\n\n// Submodule for 50 MHz clock generation\nmodule clk_div_2 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            CLK_out <= 1'b0;\n        end else begin\n            CLK_out <= ~CLK_out;\n        end\n    end\nendmodule\n\n// Submodule for 10 MHz clock generation\nmodule clk_div_10 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n    reg [3:0] cnt;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            CLK_out <= 1'b0;\n            cnt <= 0;\n        end else if (cnt == 4) begin\n            CLK_out <= ~CLK_out;\n            cnt <= 0;\n        end else begin\n            cnt <= cnt + 1;\n        end\n    end\nendmodule\n\n// Submodule for 1 MHz clock generation\nmodule clk_div_100 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n    reg [6:0] cnt;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            CLK_out <= 1'b0;\n            cnt <= 0;\n        end else if (cnt == 49) begin\n            CLK_out <= ~CLK_out;\n            cnt <= 0;\n        end else begin\n            cnt <= cnt + 1;\n        end\n    end\nendmodule"}
{"task_id": "freq_divbyeven", "code": "module verified_freq_divbyeven(\n    input clk,\n    input rst_n,\n    output clk_div\n);\n    // Parameter for division factor\n    parameter NUM_DIV = 6;\n\n    // Internal wire for the counter value\n    wire [3:0] cnt_value;\n    // Internal wire for the divided clock signal\n    wire clk_div_internal;\n\n    // Instantiate the counter submodule\n    counter #(NUM_DIV) u_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .cnt_value(cnt_value)\n    );\n\n    // Instantiate the clock divider submodule\n    clk_divider u_clk_divider (\n        .clk(clk),\n        .rst_n(rst_n),\n        .cnt_value(cnt_value),\n        .clk_div(clk_div_internal)\n    );\n\n    // Assign the internal divided clock to the output\n    assign clk_div = clk_div_internal;\n\nendmodule\n\n// Counter submodule\nmodule counter #(parameter NUM_DIV = 6)(\n    input clk,\n    input rst_n,\n    output reg [3:0] cnt_value\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            cnt_value <= 4'd0;\n        end else if (cnt_value < NUM_DIV / 2 - 1) begin\n            cnt_value <= cnt_value + 1'b1;\n        end else begin\n            cnt_value <= 4'd0;\n        end\n    end\nendmodule\n\n// Clock divider submodule\nmodule clk_divider(\n    input clk,\n    input rst_n,\n    input [3:0] cnt_value,\n    output reg clk_div\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            clk_div <= 1'b0;\n        end else if (cnt_value == 0) begin\n            clk_div <= ~clk_div;\n        end\n    end\nendmodule"}
{"task_id": "freq_divbyfrac", "code": "module verified_freq_divbyfrac(\n    input               clk,\n    input               rst_n,\n    output              clk_div\n);\n    // Parameter for fractional division factor\n    parameter MUL2_DIV_CLK = 7;\n\n    // Internal wires for clock signals\n    wire clk_ave;\n    wire clk_adjust;\n\n    // Instantiate the counter submodule\n    counter #(MUL2_DIV_CLK) u_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .cnt_value(cnt)\n    );\n\n    // Instantiate the average clock generator submodule\n    clk_average u_clk_average (\n        .clk(clk),\n        .rst_n(rst_n),\n        .cnt(cnt),\n        .clk_ave(clk_ave)\n    );\n\n    // Instantiate the clock adjustment submodule\n    clk_adjustment u_clk_adjustment (\n        .clk(clk),\n        .rst_n(rst_n),\n        .cnt(cnt),\n        .clk_adjust(clk_adjust)\n    );\n\n    // Final output: OR the adjusted and averaged clock signals\n    assign clk_div = clk_adjust | clk_ave;\n\nendmodule\n\n// Counter submodule\nmodule counter #(parameter MUL2_DIV_CLK = 7)(\n    input clk,\n    input rst_n,\n    output reg [3:0] cnt_value\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            cnt_value <= 4'b0;\n        end else if (cnt_value == MUL2_DIV_CLK - 1) begin\n            cnt_value <= 4'b0;\n        end else begin\n            cnt_value <= cnt_value + 1'b1;\n        end\n    end\nendmodule\n\n// Clock Average Generator submodule\nmodule clk_average #(parameter MUL2_DIV_CLK = 7)(\n    input clk,\n    input rst_n,\n    input [3:0] cnt,\n    output reg clk_ave\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            clk_ave <= 1'b0;\n        end else if (cnt == 0) begin\n            clk_ave <= 1'b1;  // First cycle: 4 source clock cycles\n        end else if (cnt == (MUL2_DIV_CLK / 2) + 1) begin\n            clk_ave <= 1'b1;  // Second cycle: 3 source clock cycles\n        end else begin\n            clk_ave <= 1'b0;\n        end\n    end\nendmodule\n\n// Clock Adjustment submodule\nmodule clk_adjustment #(parameter MUL2_DIV_CLK = 7)(\n    input clk,\n    input rst_n,\n    input [3:0] cnt,\n    output reg clk_adjust\n);\n    always @(negedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            clk_adjust <= 1'b0;\n        end else if (cnt == 1) begin\n            clk_adjust <= 1'b1;  // Adjust clock signal\n        end else if (cnt == (MUL2_DIV_CLK / 2) + 1) begin\n            clk_adjust <= 1'b1;  // Adjust clock signal again\n        end else begin\n            clk_adjust <= 1'b0;\n        end\n    end\nendmodule"}
{"task_id": "freq_divbyodd", "code": "module verified_freq_divbyodd(\n    input clk,\n    input rst_n,\n    output clk_div\n);\n    // Parameter for the odd divisor\n    parameter NUM_DIV = 5;\n\n    wire clk_div1, clk_div2;\n    wire [2:0] cnt1, cnt2; // 3-bit counters\n\n    // Instantiate the positive edge counter\n    pos_edge_counter #(.NUM_DIV(NUM_DIV)) u_pos_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .cnt(cnt1),\n        .clk_div(clk_div1)\n    );\n\n    // Instantiate the negative edge counter\n    neg_edge_counter #(.NUM_DIV(NUM_DIV)) u_neg_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .cnt(cnt2),\n        .clk_div(clk_div2)\n    );\n\n    // Combine the divided clocks\n    assign clk_div = clk_div1 | clk_div2;\n\nendmodule\n\nmodule pos_edge_counter(\n    input clk,\n    input rst_n,\n    output reg [2:0] cnt,\n    output reg clk_div\n);\n    parameter NUM_DIV = 5;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            cnt <= 0;\n            clk_div <= 1'b1; // Initial state\n        end else begin\n            if (cnt < NUM_DIV - 1) begin\n                cnt <= cnt + 1'b1;\n            end else begin\n                cnt <= 0;\n            end\n            \n            if (cnt < NUM_DIV / 2) begin\n                clk_div <= 1'b1;\n            end else begin\n                clk_div <= 1'b0;\n            end\n        end\n    end\nendmodule\n\nmodule neg_edge_counter(\n    input clk,\n    input rst_n,\n    output reg [2:0] cnt,\n    output reg clk_div\n);\n    parameter NUM_DIV = 5;\n\n    always @(negedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            cnt <= 0;\n            clk_div <= 1'b1; // Initial state\n        end else begin\n            if (cnt < NUM_DIV - 1) begin\n                cnt <= cnt + 1'b1;\n            end else begin\n                cnt <= 0;\n            end\n            \n            if (cnt < NUM_DIV / 2) begin\n                clk_div <= 1'b1;\n            end else begin\n                clk_div <= 1'b0;\n            end\n        end\n    end\nendmodule"}
{"task_id": "alu", "code": "`timescale 1ns / 1ps\n\nmodule verified_alu(\n    input [31:0] a,\n    input [31:0] b,\n    input [5:0] aluc,\n    output [31:0] r,\n    output zero,\n    output carry,\n    output negative,\n    output overflow,\n    output flag\n);\n\n    // Submodule instances\n    wire [32:0] add_result, sub_result, and_result, or_result, xor_result, nor_result;\n    wire [31:0] slt_result, sltu_result, sll_result, srl_result, sra_result, lui_result;\n\n    // Instantiate arithmetic operations\n    adder add(.a(a), .b(b), .result(add_result));\n    adder_unsigned addu(.a(a), .b(b), .result(add_result));\n    subtractor sub(.a(a), .b(b), .result(sub_result));\n    and_gate and1(.a(a), .b(b), .result(and_result));\n    or_gate or1(.a(a), .b(b), .result(or_result));\n    xor_gate xor1(.a(a), .b(b), .result(xor_result));\n    nor_gate nor1(.a(a), .b(b), .result(nor_result));\n\n    // Instantiate comparison operations\n    slt slt_inst(.a(a), .b(b), .result(slt_result));\n    sltu sltu_inst(.a(a), .b(b), .result(sltu_result));\n\n    // Instantiate shift operations\n    shift_left sll(.a(b), .shift_amount(a), .result(sll_result));\n    shift_right srl(.a(b), .shift_amount(a), .result(srl_result));\n    shift_arithmetic sra(.a(b), .shift_amount(a), .result(sra_result));\n    lui_module lui_inst(.a(a), .result(lui_result));\n\n    // Result selection based on aluc\n    reg [31:0] res;\n    assign r = res;\n\n    always @(*) begin\n        case (aluc)\n            6'b100000: res = add_result[31:0];   // ADD\n            6'b100001: res = add_result[31:0];   // ADDU\n            6'b100010: res = sub_result[31:0];   // SUB\n            6'b100011: res = sub_result[31:0];   // SUBU\n            6'b100100: res = and_result[31:0];   // AND\n            6'b100101: res = or_result[31:0];    // OR\n            6'b100110: res = xor_result[31:0];   // XOR\n            6'b100111: res = nor_result[31:0];   // NOR\n            6'b101010: res = slt_result;          // SLT\n            6'b101011: res = sltu_result;         // SLTU\n            6'b000000: res = sll_result;          // SLL\n            6'b000010: res = srl_result;          // SRL\n            6'b000011: res = sra_result;          // SRA\n            6'b000100: res = sll_result;          // SLLV\n            6'b000110: res = srl_result;          // SRLV\n            6'b000111: res = sra_result;          // SRAV\n            6'b001111: res = lui_result;          // LUI\n            default: res = 32'bz;                 // Default case\n        endcase\n    end\n\n    // Flags generation\n    assign zero = (res == 32'b0);\n    assign carry = add_result[32]; // Example for carry detection\n    assign negative = res[31];\n    assign overflow = (add_result[32] ^ add_result[31]) ? 1'b1 : 1'b0; // Adjust according to operations\n    assign flag = (aluc == 6'b101010) ? (a < b) : (aluc == 6'b101011) ? (a < b) : 1'bz;\n\nendmodule\n\n// Submodules definition\nmodule adder(\n    input [31:0] a,\n    input [31:0] b,\n    output [32:0] result\n);\n    assign result = {1'b0, a} + {1'b0, b}; // 33-bit result for carry\nendmodule\n\nmodule adder_unsigned(\n    input [31:0] a,\n    input [31:0] b,\n    output [32:0] result\n);\n    assign result = {1'b0, a} + {1'b0, b}; // 33-bit result for carry\nendmodule\n\nmodule subtractor(\n    input [31:0] a,\n    input [31:0] b,\n    output [32:0] result\n);\n    assign result = {1'b0, a} - {1'b0, b}; // 33-bit result for borrow\nendmodule\n\nmodule and_gate(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a & b;\nendmodule\n\nmodule or_gate(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a | b;\nendmodule\n\nmodule xor_gate(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a ^ b;\nendmodule\n\nmodule nor_gate(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = ~(a | b);\nendmodule\n\nmodule slt(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = (a < b) ? 1 : 0;\nendmodule\n\nmodule sltu(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = (a < b) ? 1 : 0;\nendmodule\n\nmodule shift_left(\n    input [31:0] a,\n    input [31:0] shift_amount,\n    output [31:0] result\n);\n    assign result = a << shift_amount;\nendmodule\n\nmodule shift_right(\n    input [31:0] a,\n    input [31:0] shift_amount,\n    output [31:0] result\n);\n    assign result = a >> shift_amount;\nendmodule\n\nmodule shift_arithmetic(\n    input [31:0] a,\n    input [31:0] shift_amount,\n    output [31:0] result\n);\n    assign result = $signed(a) >>> shift_amount;\nendmodule\n\nmodule lui_module(\n    input [31:0] a,\n    output [31:0] result\n);\n    assign result = {a[15:0], 16'b0};\nendmodule"}
{"task_id": "instr_reg", "code": "module verified_instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);\n\n    // Submodule for instruction storage\n    wire [7:0] ins_p1_out, ins_p2_out;\n\n    instruction_storage ins1 (\n        .clk(clk),\n        .rst(rst),\n        .fetch(fetch),\n        .data(data),\n        .ins_out(ins_p1_out),\n        .fetch_code(2'b01) // Fetch from register\n    );\n\n    instruction_storage ins2 (\n        .clk(clk),\n        .rst(rst),\n        .fetch(fetch),\n        .data(data),\n        .ins_out(ins_p2_out),\n        .fetch_code(2'b10) // Fetch from RAM/ROM\n    );\n\n    // Output assignments\n    assign ins = ins_p1_out[7:5]; // High 3 bits, instructions\n    assign ad1 = ins_p1_out[4:0];  // Low 5 bits, register address\n    assign ad2 = ins_p2_out;        // Full 8-bit data from second source\n\nendmodule\n\n// Submodule for instruction storage\nmodule instruction_storage (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output reg [7:0] ins_out,\n    input [1:0] fetch_code // Code to distinguish fetch sources\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ins_out <= 8'd0; // Reset output\n        end else begin\n            if (fetch == fetch_code) begin\n                ins_out <= data; // Capture data if fetch code matches\n            end else begin\n                ins_out <= ins_out; // Retain previous value\n            end\n        end\n    end\n\nendmodule"}
{"task_id": "pe", "code": "module pe(\n    input clk,\n    input rst,\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] c\n);\n\n// Intermediate wire to hold the multiplication result\nwire [63:0] mult_result;\nwire [31:0] accumulated_value;\n\n// Instantiating the multiplier module\nmultiplier u_multiplier (\n    .a(a),\n    .b(b),\n    .result(mult_result)\n);\n\n// Instantiating the accumulator module\naccumulator u_accumulator (\n    .clk(clk),\n    .rst(rst),\n    .new_value(mult_result[31:0]), // Take lower 32 bits for accumulation\n    .current_value(accumulated_value)\n);\n\n// Assigning the accumulated value to the output\nassign c = accumulated_value;\n\nendmodule\n\n// Multiplier module\nmodule multiplier(\n    input [31:0] a,\n    input [31:0] b,\n    output [63:0] result\n);\n    assign result = a * b;\nendmodule\n\n// Accumulator module\nmodule accumulator(\n    input clk,\n    input rst,\n    input [31:0] new_value,\n    output reg [31:0] current_value\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            current_value <= 0;\n        end else begin\n            current_value <= current_value + new_value;\n        end\n    end\nendmodule"}
{"task_id": "signal_generator", "code": "module verified_signal_generator (\n    input clk,\n    input rst_n,\n    output [4:0] wave\n);\n\n    wire [1:0] state;\n    reg [4:0] wave_reg;\n\n    // State Control Module\n    state_control state_inst (\n        .clk(clk),\n        .rst_n(rst_n),\n        .wave(wave_reg),\n        .state(state)\n    );\n\n    // Waveform Generation Module\n    waveform_gen wave_inst (\n        .clk(clk),\n        .rst_n(rst_n),\n        .state(state),\n        .wave(wave_reg)\n    );\n\n    assign wave = wave_reg;\n\nendmodule\n\n// State Control Module\nmodule state_control (\n    input clk,\n    input rst_n,\n    input [4:0] wave,\n    output reg [1:0] state\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (~rst_n) begin\n            state <= 2'b00;\n        end else begin\n            case (state)\n                2'b00:\n                    if (wave == 5'b11111) // 31\n                        state <= 2'b01;\n                2'b01:\n                    if (wave == 5'b00000) // 0\n                        state <= 2'b00;\n            endcase\n        end\n    end\n\nendmodule\n\n// Waveform Generation Module\nmodule waveform_gen (\n    input clk,\n    input rst_n,\n    input [1:0] state,\n    output reg [4:0] wave\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (~rst_n) begin\n            wave <= 5'b0;\n        end else begin\n            case (state)\n                2'b00:\n                    wave <= wave + 1;\n                2'b01:\n                    wave <= wave - 1;\n            endcase\n        end\n    end\n\nendmodule"}
{"task_id": "square_wave", "code": "module verified_square_wave(\n    input clk,\n    input [7:0] freq,\n    output wave_out\n);\n\n    wire count_enable;\n    wire [7:0] count_value;\n\n    // Instance of counter module\n    counter cnt (\n        .clk(clk),\n        .enable(count_enable),\n        .freq(freq),\n        .count(count_value)\n    );\n\n    // Instance of wave generator module\n    wave_generator wg (\n        .clk(clk),\n        .count(count_value),\n        .freq(freq),\n        .wave_out(wave_out)\n    );\n\n    // Control logic for enabling the counter\n    assign count_enable = (freq > 0);\n\nendmodule\n\nmodule counter(\n    input clk,\n    input enable,\n    input [7:0] freq,\n    output reg [7:0] count\n);\n\n    initial begin\n        count = 0;\n    end\n\n    always @(posedge clk) begin\n        if (enable) begin\n            if (count == freq - 1) begin\n                count <= 0;\n            end else begin\n                count <= count + 1;\n            end\n        end\n    end\n\nendmodule\n\nmodule wave_generator(\n    input clk,\n    input [7:0] count,\n    input [7:0] freq,\n    output reg wave_out\n);\n\n    initial begin\n        wave_out = 0;\n    end\n\n    always @(posedge clk) begin\n        if (count == freq - 1) begin\n            wave_out <= ~wave_out;\n        end\n    end\n\nendmodule"}
